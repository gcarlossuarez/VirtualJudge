<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Juez Online</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .tab { display: inline-block; padding: 10px 20px; margin-right: 5px; border: 1px solid #ccc; border-bottom: none; cursor: pointer; background: #eee; }
    .tab.active { background: #fff; font-weight: bold; }
    .editor-container { border: 1px solid #ccc; padding: 10px; }
    .CodeMirror { border: 1px solid #ccc; height: 300px; font-size: 14px; }
    #monaco-container { width: 100%; height: 300px; border: 1px solid #ccc; display: none; }
    .result { margin-top: 20px; padding: 10px; border-radius: 5px; white-space: pre-wrap; }
    .ok { background: #e0ffe0; border: 1px solid #0c0; }
    .warn { background: #fff5cc; border: 1px solid #cc0; }
    .err { background: #ffe0e0; border: 1px solid #c00; }
    
    /* Estilo para el log de validaci√≥n */
    #validationLog {
      background-color: #f8f9fa;
      color: #212529;
      padding: 15px;
      border: 1px solid #dee2e6;
      border-radius: 5px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.6;
      max-height: 500px;
      overflow-y: auto;
    }
    
    /* Estilo para agrupar botones del sandbox local */
    .sandbox-group {
      margin-top: 15px;
      padding: 15px;
      border: 2px solid #3498db;
      border-radius: 8px;
      background-color: #ecf8ff;
      box-shadow: 0 2px 4px rgba(52, 152, 219, 0.2);
    }
    .sandbox-group-title {
      font-weight: bold;
      color: #2980b9;
      margin-bottom: 10px;
      font-size: 14px;
    }
    
    #stdin {
      resize: both;         /* permite agrandar con el mouse */
      min-height: 150px;    /* alto m√≠nimo */
      min-width: 300px;     /* ancho m√≠nimo */
      width: 100%;          /* por defecto ocupa todo el ancho */
    }
    
    
    #utils-panel {
      float: left;
      width: 25%;
      height: 400px;
      overflow-y: auto;
      border: 1px solid #ccc;
      padding: 5px;
      font-family: monospace;
      background: #f9f9f9;
    }

    #utils-viewer {
      margin-left: 26%;
      height: 400px;
    }

    #utils-content {
      width: 100%;
      height: 100%;
      font-family: monospace;
      white-space: pre;
    }
    .folder { cursor: pointer; font-weight: bold; }
    .file { cursor: pointer; margin-left: 15px; }

    #copy-btn {
      margin-bottom: 5px;
      padding: 5px 10px;
      font-size: 14px;
      cursor: pointer;
      background: #4caf50;
      color: white;
      border: none;
      border-radius: 5px;
    }
    #copy-btn:hover {
      background: #45a049;
    }

    /* Toast container */
    #toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
    }

    /* Toast message */
    .toast {
      background: #333;
      color: white;
      padding: 10px 20px;
      margin-top: 5px;
      border-radius: 5px;
      font-size: 14px;
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.5s, transform 0.5s;
    }

    /* Visible state */
    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }
    
    /* Cambia el color de fondo de las textarea de solo lectura */ 
    textarea[readonly] {
      background-color: #f4f4f4; /* gris claro */
      color: #333;              /* texto m√°s oscuro */
      border: 1px solid #ccc;
    }

    /* Cambia el color de fondo de los text de solo lectura */ 
    input[readonly] {
       background-color: #fff8dc; /* palido, tipo bloc de notas */
    }

    /* Cambio suave entre tema */
    body, textarea, input, select {
      transition: background-color 0.3s, color 0.3s;
    }

    /* Animaci√≥n para el banner de advertencia */
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.85; }
    }

    /* Ajuste del body para dejar espacio al banner */
    body {
      padding-top: 65px;
    }

  </style>
  
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin:0; padding:0; }

    /* Bot√≥n flotante */
    .floating-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: #0056b3;
      color: white;
      padding: 15px 20px;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      font-size: 16px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      z-index: 10000;
    }
    .floating-btn:hover { background-color: #004494; }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      z-index: 9999;
      left: 0; top: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.6);
    }
    .modal-content {
      background: #fff;
      margin: 5% auto;
      padding: 20px;
      border-radius: 10px;
      width: 80%;
      max-height: 80%;
      overflow-y: auto;
    }
    .close {
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    pre {
      background: #eee;
      padding: 10px;
      border-radius: 5px;
      position: relative;
      overflow-x: auto;
    }
    .copy-btn {
      position: absolute;
      top: 5px; right: 5px;
      background: #444;
      color: white;
      border: none;
      padding: 5px 10px;
      font-size: 12px;
      cursor: pointer;
      border-radius: 3px;
    }
    .copy-btn:hover { background: #222; }
    
    /* === Tema oscuro === */
    body.dark-mode {
      background-color: #1e1e1e;
      color: #ddd;
    }

    body.dark-mode textarea,
    body.dark-mode input,
    body.dark-mode select {
      background-color: #2b2b2b;
      color: #eee;
      border-color: #555;
    }

    body.dark-mode .editor-container,
    body.dark-mode #utils-panel,
    body.dark-mode #utils-viewer,
    body.dark-mode .result {
      background-color: #252526;
      border-color: #555;
      color: #ddd;
    }

    body.dark-mode #copy-btn {
      background: #006400;
    }

    body.dark-mode .tab {
      background: #333;
      color: #ccc;
      border-color: #555;
    }

    body.dark-mode .tab.active {
      background: #1e1e1e;
      color: #fff;
      border-bottom: 1px solid #1e1e1e;
    }

    body.dark-mode #toast-container .toast {
      background: #444;
    }

    /* Modo oscuro para el log de validaci√≥n */
    body.dark-mode #validationLog {
      background-color: #1e1e1e;
      color: #d4d4d4;
      border-color: #3c3c3c;
    }

  </style>
  
  <!-- CodeMirror -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/clike/clike.min.js"></script>
  
  <!--
  El archivo monokai.min.css define los colores de sintaxis, fondo, n√∫meros de l√≠nea, etc. para CodeMirror cuando se usa el tema "monokai".
  Por ejemplo:
  - Fondo negro (#272822)
  - Texto claro
  - Keywords en azul/verde
  - Literales en naranja
  -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/monokai.min.css">

  <!-- Monaco -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>
  <script>
    /* Esperar a que el loader de Monaco est√© disponible; ya que, el require de Monaco a√∫n no est√° definido en ese punto
   cuando se carga el script (porque loader.min.js se ejecuta de forma as√≠ncrona).*/ 
    window.addEventListener("load", () => {
      require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' } });
      require(['vs/editor/editor.main'], function () {
        console.log("‚úÖ Monaco base cargado");
      });
    });
  </script>

  </head>
  
  
  <body>

  <!-- Banner de advertencia - Registro obligatorio -->
  <div id="warning-banner" style="
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
    color: white;
    padding: 15px 20px;
    text-align: center;
    font-size: 18px;
    font-weight: bold;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    z-index: 999999;
    border-bottom: 3px solid #d94452;
    animation: pulse 2s ease-in-out infinite;
  ">
    ‚ö†Ô∏è IMPORTANTE: Antes de comenzar, debes seleccionar tu nombre en la lista de estudiantes. Todas tus actividades quedar√°n registradas para evaluaci√≥n.
  </div>

  <!-- Bot√≥n flotante -->
  <button class="floating-btn" onclick="openModal()">üìò Reglas</button>

  <!-- Modal -->
  <div id="reglasModal" class="modal">
    <div class="modal-content">
      <span class="close" onclick="closeModal()">&times;</span>
      <div id="markdown-content"></div>
    </div>
  </div>

  <script>
  function openModal() {
    document.getElementById("reglasModal").style.display = "block";
    fetch("Juez_Virtual_Instructivo.markdown")
      .then(res => res.text())
      .then(text => {
        const html = marked.parse(text);
        document.getElementById("markdown-content").innerHTML = html;
        addCopyButtons();
      });
  }

  function closeModal() {
    document.getElementById("reglasModal").style.display = "none";
  }

  function addCopyButtons() {
    document.querySelectorAll("pre code").forEach(block => {
      // Evitar duplicados
      if (block.parentNode.querySelector(".copy-btn")) return;
      const button = document.createElement("button");
      button.innerText = "üìã Copiar";
      button.className = "copy-btn";
      button.onclick = () => {
        navigator.clipboard.writeText(block.innerText);
        button.innerText = "‚úÖ Copiado!";
        setTimeout(() => button.innerText = "üìã Copiar", 2000);
      };
      block.parentNode.style.position = "relative";
      block.parentNode.appendChild(button);
    });
  }
  </script>

  
  <h1>Juez Online</h1>
  <button id="theme-toggle" style="
              position: fixed;
              bottom: 90px;
              right: 20px;
              background-color: #333;
              color: white;
              padding: 10px 15px;
              border: none;
              border-radius: 50px;
              cursor: pointer;
              font-size: 16px;
              box-shadow: 0 4px 6px rgba(0,0,0,0.3);
              z-index: 10000;">üåô</button>

  <div>
    <div id="tab-cm" class="tab active" onclick="switchEditor('cm')">Editor r√°pido (CodeMirror)</div>
    <div id="tab-monaco" class="tab" onclick="switchEditor('monaco')">Editor avanzado (Monaco)</div>
  </div>

  <p id="monaco-warning" style="color:red; display:none;">
    ‚ö†Ô∏è El editor Monaco es m√°s pesado, puede tardar unos segundos en cargar.
  </p>

  <label id="lblProblemId">Id del Problema:</label>
  <input type="text" id="txtProblemId" style="width: 40px;" required minlength="1" readonly>
  <span>
    <label for="selectProblem">Seleccione el problema:</label>
    <select id="selectProblem">
      <option value="">-- Seleccione --</option>
    </select>
    <button id="btnRefreshProblems" onclick="refreshProblems()" 
            style="margin-left: 10px; background-color: #17a2b8; color: white; padding: 5px 10px; border: none; border-radius: 3px; cursor: pointer;"
            title="Actualizar enunciados desde el servidor">
      üîÑ Actualizar Problemas
    </button>
  </span>
  <span>
    <label for="selectInput">Seleccione dataset:</label>
    <select id="selectInput">
      <option value="">-- Seleccione un dataset --</option>
    </select>
  </span>
  <br><br>

  <label id="lblStudentId">Id del Estudiante:</label>
  <input type="text" id="txtStudentId" style="width: 100px;" required minlength="1" readonly>
  <span>
    <label for="selectStudent">O selecciona tu nombre:</label>
    <select id="selectStudent">
      <option value="">-- Selecciona tu nombre --</option>
    </select>
  </span>
  <br><br>
  
  <label for="txtProblemDesc">Descripci√≥n del problema:</label><br>
  <textarea id="txtProblemDesc" rows="30" cols="200" readonly></textarea>
  
  <div id="utils-panel">
    <h3>üìÇ <strong><i>UTILITARIOS PARA REFERENCIA DE SINTAXIS E INSTRUCCIONES EN C#</i></strong></h3>
    <div id="utils-tree"></div>
  </div>

  <div id="utils-viewer">
    <h3>üìÑ Contenido del archivo en <strong>Utilitarios</strong></h3>
    <button id="copy-btn">üìã Copiar al portapapeles</button>
    <textarea id="utils-content" readonly></textarea>
  </div>

    <label for="selectLanguage">Lenguaje:</label>
  <select id="selectLanguage">
    <option value="csharp">C#</option>
    <option value="cpp">C++</option>
    <!-- futuro: <option value="python">Python</option> -->
  </select>
  <br><br>

  <div class="editor-container">
    <textarea id="code-cm"></textarea>
  <div id="monaco-container"></div>
  </div>



  <script>
    // BOOKMARK: Configuraci√≥n de lenguajes (C#, C++)
    // ‚ö° Mapear lenguaje elegido ‚Üí configuraci√≥n de editores + Judge0
    const LANG_CONFIG = {
      csharp: {
        codemirror: "text/x-csharp",
        monaco: "csharp",
        judge0: 51,
        filename: "solucion.cs",
        template: `using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

class Program
{
    static void Main()
    {
        string line;
        
        // Leer hasta que no haya m√°s l√≠neas (hasta el final del stream)
        while ((line = Console.ReadLine()) != null)
        {
            Console.WriteLine($"valor enviado={line}");
        }
        Console.WriteLine("Hola C#!");
    }
}`
      },
      cpp: {
        codemirror: "text/x-c++src",
        monaco: "cpp",
        judge0: 54,
        filename: "solucion.cpp",
        template: `  #include <bits/stdc++.h>
  using namespace std;
  int main() {
      string line;
      while (getline(cin, line)) {
          cout << "valor enviado=" << line << endl;
      }
      cout << "Hola C++!" << endl;
      return 0;
  }`
      }
    };

    let monacoEditor = null;


    function getSelectedLang() {
      const val = document.getElementById("selectLanguage").value;
      return LANG_CONFIG[val] || LANG_CONFIG.csharp;
    }

    // === Inicializar CodeMirror con c√≥digo por defecto ===
    const defaultConfig = getSelectedLang();
    const cmEditor = CodeMirror.fromTextArea(document.getElementById("code-cm"), {
      lineNumbers: true,
      mode: defaultConfig.codemirror,
      theme: "default"
    });
    
    // Establecer el contenido inicial
    cmEditor.setValue(defaultConfig.template);
    
    // Mostrar el c√≥digo en la consola (para depuraci√≥n)
    function showCodeParamInConsole(code) {
      console.log("=== C√ìDIGO ACTUAL ===");
      console.log(code);
      console.log("=== FIN DEL C√ìDIGO ===");
    }

    // Obtener el c√≥digo actual (de CodeMirror o Monaco)
    function showCodeInConsole() {
        const code = getCurrentCode();
        showCodeParamInConsole(code);
    }

    // BOOKMARK: Cambio entre editores CodeMirror y M√≥naco
    // === Funci√≥n switchEditor (debe estar disponible globalmente) ===
    function switchEditor(type) {
      // Depurar, en la consola, el c√≥digo actual
      console.log("=== C√ìDIGO ACTUAL ANTES DE CAMBIAR DE EDITOR DE C√ìDIGO ===");
      showCodeInConsole();

      document.getElementById("tab-cm").classList.remove("active");
      document.getElementById("tab-monaco").classList.remove("active");
      
      if (type === "cm") {
        document.getElementById("tab-cm").classList.add("active");
        document.getElementById("monaco-container").style.display = "none";
        document.getElementById("monaco-warning").style.display = "none";
        cmEditor.getWrapperElement().style.display = "block";
      } else {
        document.getElementById("tab-monaco").classList.add("active");
        document.getElementById("monaco-container").style.display = "block";
        document.getElementById("monaco-warning").style.display = "block";
        cmEditor.getWrapperElement().style.display = "none";
        
        // Asegurarse de que Monaco se redibuje correctamente
        if (monacoEditor) {
          setTimeout(() => monacoEditor.layout(), 50);
        }
      }
    }

    // === Inicializaci√≥n de Monaco ===
    require.config({ 
      paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' } 
    });

    require(["vs/editor/editor.main"], function () {
      monacoEditor = monaco.editor.create(document.getElementById('monaco-container'), {
        value: `using System;
using System.Linq; // Para utilizar poder Linq
using System.Collections.Generic; // Para poder trabajar con listas, diccionarios, etc.

// Ejemplo para ser probado en Monaco (con entrada desde teclado).
class Program
{
    static void Main()
    {
        string val;
        while (!string.IsNullOrEmpty(val = Console.ReadLine()))
        {
            Console.WriteLine($"Valor enviado={val}");
        }
        Console.WriteLine("Hola Monaco!");
    }
}`,
        language: "csharp",
        theme: "vs-light",
        automaticLayout: true
      });
      console.log("‚úÖ Monaco cargado correctamente");
    });

    // === Cambio de lenguaje (compatible con CodeMirror y Monaco) ===
    document.getElementById("selectLanguage").addEventListener("change", () => {
      const cfg = getSelectedLang();

      // Depurar, en la consola, el c√≥digo actual antes de cambiar
      console.log("=== C√ìDIGO ACTUAL ANTES DE CAMBIAR DE LENGUAJE ===");
      showCodeInConsole();

      // CodeMirror
      cmEditor.setOption("mode", cfg.codemirror);
      cmEditor.setValue(cfg.template);

      // Monaco (si ya est√° creado)
      if (monacoEditor) {
        monaco.editor.setModelLanguage(monacoEditor.getModel(), cfg.monaco);
        monacoEditor.setValue(cfg.template);
        monacoEditor.layout();
      }
    });

    // === Inicializar CodeMirror con plantilla inicial ===
    window.addEventListener("load", () => {
      const cfg = getSelectedLang();
      cmEditor.setOption("mode", cfg.codemirror);
      cmEditor.setValue(cfg.template);
    });


    
  </script>

  <script>
    // Hacer el envio
    const JUDGE0_URL = "https://ce.judge0.com/submissions?base64_encoded=true&wait=true";

    function getCurrentCode() {
      if (document.getElementById("tab-cm").classList.contains("active")) {
        return cmEditor.getValue();
      } else {
        return monacoEditor ? monacoEditor.getValue() : "";
      }
    }

    // BOOKMARK: Ejecuci√≥n en Judge0 (juez de prueba)
    async function runJudge0() {
      const code = getCurrentCode();
      
      let stdin = document.getElementById('stdin').value;

      const log = document.getElementById("validationLog");
      log.textContent = "";

      if (!code.trim()) {
        showMessage("‚ö†Ô∏è El c√≥digo est√° vac√≠o, no se puede enviar a Judge0.", "err");
        return;
      }

      console.log("=== C√ìDIGO ACTUAL ANTES DE ENVIAR A JUDGE0 ===");
      showCodeParamInConsole(code);

      showMessage("‚è≥ Ejecutando en Judge0...", "warn");

      try {
        const response = await fetch(JUDGE0_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            // üëá importante: enviar como Base64
            source_code: btoa(unescape(encodeURIComponent(code))),
            language_id: getSelectedLang().judge0,
            stdin: btoa(unescape(encodeURIComponent(stdin)))
          })
        });

        if (!response.ok) {
          const errText = await response.text();
          showMessage("‚ùå Judge0 devolvi√≥ " + response.status + ":\n" + errText, "err");
          return;
        }

        const result = await response.json();
        
        function decodeBase64(b64) {
          try {
            return decodeURIComponent(escape(atob(b64)));
          } catch (e) {
            return b64; // si no es v√°lido, lo dejo tal cual
          }
        }

        const stdout = result.stdout ? decodeBase64(result.stdout) : "";
        const stderr = result.stderr ? decodeBase64(result.stderr) : "";
        const compile_output = result.compile_output ?    decodeBase64(result.compile_output) : "";

        if (stderr || compile_output) {
          showMessage("‚ùå Error:\n" + (stderr || compile_output), "err");
        } else {
          showMessage("‚úÖ Salida:\n" + stdout +
                      "\n\nEstado: " + (result.status?.description || "??"), "ok");
        }
      } catch (err) {
        showMessage("‚ö†Ô∏è Error al conectar con Judge0:\n" + err, "err");
      }
    }

    // BOOKMARK: Ejecuci√≥n en servidor oficial (calificable)
    async function runOfficial() {
      const problemId = document.getElementById('txtProblemId').value;
      const studentId = document.getElementById('txtStudentId').value;
      const code = getCurrentCode();
      const stdin = document.getElementById('stdin').value;

      const log = document.getElementById("validationLog");
      log.textContent = "";

      if (!problemId) { alert("Por favor, introduce el identificador de la pregunta."); return; }
      if (!studentId) { alert("Por favor, introduce el identificador del estudiante."); return; }

      if (!code.trim()) {
        showMessage("‚ö†Ô∏è El c√≥digo est√° vac√≠o, no se puede enviar a Judge0.", "err");
        return;
      }

      console.log("=== C√ìDIGO ACTUAL ANTES DE ENVIAR AL SERVIDOR OFICIAL ===");
      showCodeParamInConsole(code);

      showMessage("‚è≥ Enviando a servidor oficial...", "warn");

      try {
        const formData = new FormData();
        const blob = new Blob([code], { type: "text/plain" });
        formData.append("code", blob, getSelectedLang().filename);
        formData.append("language", document.getElementById("selectLanguage").value);
        formData.append("stdin", stdin);
        formData.append("problemId", problemId);
        formData.append("studentId", studentId);

        const response = await fetch("/compile-run", {
          method: "POST",
          body: formData
        });

        if (!response.ok) {
          const errorText = await response.text();
          showMessage("‚ùå Error del servidor:\n" + errorText, "err");
          return;
        }

        const result = await response.json();
        if (result.build !== "build:ok") {
          showMessage("‚ùå Errores de compilaci√≥n:\n" + (result.buildLog || "Sin detalles"), "err");
          return;
        }
        if (result.run !== "run:ok") {
          showMessage("‚ùå Error en ejecuci√≥n:\n" +
            (result.runLog || "Sin detalles") +
            (result.stderrRaw ? "\nSTDERR:\n" + result.stderrRaw : "") +
            "\nüìù Summary: " + (result.summary),
            "err"
          );
          return;
        }

        showMessage("‚úÖ Ejecuci√≥n exitosa\n\nSalida:\n" + (result.runLog || "") +
          "\n\n‚è± Tiempo: " + (result.time || "-") +
          "\nüíæ Memoria: " + (result.memKb || "-") + " KB" +
          "\nüìù Summary: " + (result.summary),
          "ok"
        );

      } catch (err) {
        showMessage("‚ö†Ô∏è No se pudo conectar al servidor oficial:\n" + err, "err");
      }
    }

    function showMessage(msg, type) {
      const out = document.getElementById("output");
      if (!out) {
        console.error("‚ö†Ô∏è Elemento 'output' no encontrado en el DOM");
        return;
      }
      out.className = "result " + type;
      out.textContent = msg;
    }
  </script>

  <br>
  <label for="stdin">Entrada (stdin):</label><br>
  <textarea id="stdin" rows="15" cols="80" style="width: 100%;"></textarea>

  <button id="btnJudge0" type="button" onclick="runJudge0()">Ejecutar (En Juez de<br>Prueba)</button>
  <button id="btnOfficial" type="button" onclick="runOfficial()">Enviar (En Juez Oficial,<br> <strong>es calificable para el contest</strong>)</button>

  <!-- Grupo de Sandbox Local -->
  <div class="sandbox-group">
    <div class="sandbox-group-title">üñ•Ô∏è SANDBOX LOCAL (Solo Windows x64)</div>
    <div>
      <button id="btnSandbox" onclick="runLocalCode()" disabled title="Verificando sandbox...">üß™ Probar en Sandbox</button>
      <button id="btnValidation" onclick="runOfflineValidation()" disabled title="Verificando sandbox...">üìÇ Validar con DataSet local</button>
      <button id="btnCancelValidation" onclick="cancelValidation()" style="display: none; background-color: #dc3545; color: white;">üõë Cancelar Validaci√≥n</button>
      <button id="btnClearDataset" onclick="clearDataset()" disabled title="Limpiar el dataset del problema actual" style="background-color: #e74c3c; color: white;">üóëÔ∏è Limpiar Dataset</button>
    </div>
    <div style="margin-top: 8px;">
      <button id="btnDownloadSandbox" onclick="downloadSandbox()" style="background-color: #ff9800;">üì• Descargar Sandbox</button>
      <button id="btnDownloadDotnet" onclick="downloadDotnetSDK()" style="background-color: #512bd4; color: white;" 
              title="‚ö†Ô∏è Solo Windows x64 - No necesario si ya tienes .NET SDK 10 instalado">‚¨áÔ∏è Descargar .NET 10 SDK</button>
    </div>
  </div>

  <pre id="validationLog"></pre>
  <div id="output" class="result"></div>

  
  <script>
    // BOOKMARK: Configuraci√≥n de URLs del servidor y sandbox
    // Constantes de configuraci√≥n
    // Esta URL ser√° reemplazada por el script start_judge.sh con la URL de ngrok
    const SERVER_BASE_URL = "https://realtor-subscribers-blowing-physicians.trycloudflare.com";
    const SANDBOX_BASE = "http://localhost:1100";
    const SANDBOX_URL = SANDBOX_BASE; // Alias para compatibilidad
    
    // Descargar desde Google Drive (no consume ancho de banda del servidor)
    // NUEVA URL DE DESCARGA DEL SANDBOX (2025-11-24)
    // NUEVA URL DE DESCARGA DEL SANDBOX LOCAL (2025-11-26)
    const SANDBOX_DOWNLOAD_URL = "https://drive.google.com/file/d/1ykvui0j3xqzo2IyIc5r6sKta6QPJT_WP/view?usp=sharing";

    // Estado del sandbox
    let sandboxAvailable = false;
    let isValidating = false; // Bandera para saber si estamos validando
    let checkInterval = null;
    let isWindows64 = false;
    
    // Control de cancelaci√≥n de validaci√≥n
    let validationAbortController = null;
    let validationReader = null;

    // BOOKMARK: Funci√≥n para cancelar validaci√≥n
    function cancelValidation() {
      console.log('üõë Cancelando validaci√≥n...');
      
      // Cancelar el fetch con AbortController
      if (validationAbortController) {
        validationAbortController.abort();
        validationAbortController = null;
      }
      
      // Cancelar el reader del stream
      if (validationReader) {
        validationReader.cancel();
        validationReader = null;
      }
      
      // Ocultar bot√≥n de cancelar
      const btnCancel = document.getElementById('btnCancelValidation');
      if (btnCancel) btnCancel.style.display = 'none';
      
      // Mostrar mensaje de cancelaci√≥n
      const output = document.getElementById('output');
      const log = document.getElementById('validationLog');
      if (output) {
        output.textContent = 'üõë Validaci√≥n cancelada por el usuario';
        output.className = 'result warn';
      }
      if (log) {
        log.textContent += '\nüõë Validaci√≥n cancelada por el usuario\n';
      }
      
      // Marcar que ya no estamos validando y rehabilitar botones
      isValidating = false;
      enableSandboxButtons();
      
      console.log('‚úÖ Validaci√≥n cancelada exitosamente');
    }

    // BOOKMARK: Funci√≥n para limpiar el dataset de un problema
    async function clearDataset() {
      if(isValidating) {
        alert('‚ö†Ô∏è No se puede limpiar el dataset mientras una validaci√≥n est√° en curso. Por favor, cancela la validaci√≥n primero.');
        return;
      }
      const problemId = document.getElementById('txtProblemId').value;
      
      if (!problemId) {
        alert('‚ö†Ô∏è Por favor, selecciona un problema primero.');
        return;
      }

      const confirmClear = confirm(
        `üóëÔ∏è ¬øEst√°s seguro de que deseas limpiar el dataset del problema ${problemId}?\n\n` +
        `Esto eliminar√° todos los archivos de entrada y salida esperada descargados.\n\n` +
        `√ötil cuando el profesor ha actualizado el dataset y necesitas descargarlo de nuevo.`
      );

      if (!confirmClear) {
        console.log('‚ùå Usuario cancel√≥ la limpieza del dataset');
        return;
      }

      const btnClear = document.getElementById('btnClearDataset');
      const originalText = btnClear.textContent;
      
      try {
        btnClear.disabled = true;
        btnClear.textContent = '‚è≥ Limpiando...';
        
        console.log(`üóëÔ∏è Limpiando dataset del problema ${problemId}...`);
        
        const response = await fetch(`${SANDBOX_BASE}/datasets/${encodeURIComponent(problemId)}`, {
          method: 'DELETE'
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const result = await response.json();
        
        console.log('‚úÖ Dataset limpiado:', result);
        
        alert(
          `‚úÖ ${result.message}\n\n` +
          `Problema: ${result.problemId}\n\n` +
          `La pr√≥xima vez que ejecutes una validaci√≥n, el dataset se descargar√° autom√°ticamente de nuevo.`
        );
        
      } catch (error) {
        console.error('‚ùå Error al limpiar dataset:', error);
        
        let errorMsg = '‚ùå Error al limpiar el dataset:\n\n';
        
        if (error.message.includes('Failed to fetch')) {
          errorMsg += 'üîå No se puede conectar con el sandbox local.\n' +
                      'Aseg√∫rate de que DotNetInteractiveServer.exe est√© ejecut√°ndose en localhost:1100';
        } else if (error.message.includes('404')) {
          errorMsg += `üìÇ El dataset del problema ${problemId} no existe o ya fue eliminado.`;
        } else {
          errorMsg += error.message;
        }
        
        alert(errorMsg);
        
      } finally {
        btnClear.disabled = false;
        btnClear.textContent = originalText;
      }
    }

    // BOOKMARK:Detectar sistema operativo
    function detectOS() {
      const userAgent = navigator.userAgent.toLowerCase();
      const platform = navigator.platform.toLowerCase();
      
      // Detectar Windows
      const isWindows = userAgent.includes('win') || platform.includes('win');
      
      // Detectar 64 bits
      // WOW64 = Windows 32-bit on Windows 64-bit
      // Win64 = Windows 64-bit nativo
      const is64bit = userAgent.includes('win64') || 
                      userAgent.includes('wow64') || 
                      platform.includes('win64') ||
                      navigator.userAgentData?.platform === 'Windows';
      
      return {
        isWindows: isWindows,
        is64bit: is64bit,
        isWindows64: isWindows && is64bit,
        osName: isWindows ? 'Windows' : 
                userAgent.includes('mac') ? 'macOS' : 
                userAgent.includes('linux') ? 'Linux' : 'Desconocido'
      };
    }

    // BOOKMARK: Verificaci√≥n de configuraci√≥n del servidor para sandbox
    // Deshabilitar sandbox si est√° deshabilitado por configuraci√≥n del servidor
    function disableSandboxByConfiguration() {
      console.log('‚ö†Ô∏è Sandbox deshabilitado por configuraci√≥n del servidor');
      
      const btnSandbox = document.getElementById('btnSandbox');
      const btnValidation = document.getElementById('btnValidation');
      const btnClearDataset = document.getElementById('btnClearDataset');
      const btnDownloadSandbox = document.getElementById('btnDownloadSandbox');
      const btnDownloadSDK = document.getElementById('btnDownloadSDK');
      
      if (btnSandbox) {
        btnSandbox.disabled = true;
        btnSandbox.title = '‚ö†Ô∏è Sandbox deshabilitado por configuraci√≥n del servidor';
      }
      
      if (btnValidation) {
        btnValidation.disabled = true;
        btnValidation.title = '‚ö†Ô∏è Sandbox deshabilitado por configuraci√≥n del servidor';
      }
      
      if (btnClearDataset) {
        btnClearDataset.disabled = true;
        btnClearDataset.title = '‚ö†Ô∏è Sandbox deshabilitado por configuraci√≥n del servidor';
      }
      
      if (btnDownloadSandbox) {
        btnDownloadSandbox.disabled = true;
        btnDownloadSandbox.title = '‚ö†Ô∏è Sandbox deshabilitado por configuraci√≥n del servidor';
      }
      
      if (btnDownloadSDK) {
        btnDownloadSDK.disabled = true;
        btnDownloadSDK.title = '‚ö†Ô∏è Sandbox deshabilitado por configuraci√≥n del servidor';
      }
      
      alert('‚ö†Ô∏è El Sandbox Local est√° deshabilitado por configuraci√≥n del servidor.\n\n' +
            'Por favor, utiliza las opciones "Enviar en Judge0" o "Enviar en Juez Oficial".');
    }

    // BOOKMARK: Control de registro obligatorio de estudiante
    // Variable global para rastrear si el estudiante se ha registrado
    let studentRegistered = false;

    // Funci√≥n para deshabilitar todos los controles al inicio
    function disableAllControlsForRegistration() {
      console.log('üîí Deshabilitando todos los controles - Esperando registro de estudiante');
      
      // Deshabilitar selectores de problemas y dataset
      const selectProblem = document.getElementById('selectProblem');
      const selectInput = document.getElementById('selectInput');
      const selectLanguage = document.getElementById('selectLanguage');
      const btnRefreshProblems = document.getElementById('btnRefreshProblems');
      
      if (selectProblem) selectProblem.disabled = true;
      if (selectInput) selectInput.disabled = true;
      if (selectLanguage) selectLanguage.disabled = true;
      if (btnRefreshProblems) btnRefreshProblems.disabled = true;
      
      // Deshabilitar editores
      const codeCm = document.getElementById('code-cm');
      if (codeCm) codeCm.disabled = true;
      
      // Si Monaco est√° cargado, tambi√©n deshabilitarlo
      if (typeof monacoEditor !== 'undefined' && monacoEditor) {
        monacoEditor.updateOptions({ readOnly: true });
      }
      
      // Deshabilitar todos los botones de ejecuci√≥n
      const btnJudge0 = document.getElementById('btnJudge0');
      const btnOfficial = document.getElementById('btnOfficial');
      const btnSandbox = document.getElementById('btnSandbox');
      const btnValidation = document.getElementById('btnValidation');
      const btnClearDataset = document.getElementById('btnClearDataset');
      const btnDownloadSandbox = document.getElementById('btnDownloadSandbox');
      const btnDownloadDotnet = document.getElementById('btnDownloadDotnet');
      
      if (btnJudge0) {
        btnJudge0.disabled = true;
        btnJudge0.title = 'Primero debes seleccionar tu nombre';
      }
      if (btnOfficial) {
        btnOfficial.disabled = true;
        btnOfficial.title = 'Primero debes seleccionar tu nombre';
      }
      if (btnSandbox) {
        btnSandbox.disabled = true;
        btnSandbox.title = 'Primero debes seleccionar tu nombre';
      }
      if (btnValidation) {
        btnValidation.disabled = true;
        btnValidation.title = 'Primero debes seleccionar tu nombre';
      }
      if (btnClearDataset) {
        btnClearDataset.disabled = true;
        btnClearDataset.title = 'Primero debes seleccionar tu nombre';
      }
      if (btnDownloadSandbox) {
        btnDownloadSandbox.disabled = true;
        btnDownloadSandbox.title = 'Primero debes seleccionar tu nombre';
      }
      if (btnDownloadDotnet) {
        btnDownloadDotnet.disabled = true;
        btnDownloadDotnet.title = 'Primero debes seleccionar tu nombre';
      }
      
      // Deshabilitar tabs de editor
      const tabCm = document.getElementById('tab-cm');
      const tabMonaco = document.getElementById('tab-monaco');
      if (tabCm) tabCm.style.pointerEvents = 'none';
      if (tabMonaco) tabMonaco.style.pointerEvents = 'none';
    }

    // Funci√≥n para habilitar todos los controles despu√©s de registro exitoso
    function enableAllControlsAfterRegistration() {
      console.log('üîì Habilitando controles - Estudiante registrado exitosamente');
      studentRegistered = true;
      
      // Ocultar banner de advertencia con animaci√≥n
      const banner = document.getElementById('warning-banner');
      if (banner) {
        banner.style.transition = 'opacity 0.5s, transform 0.5s';
        banner.style.opacity = '0';
        banner.style.transform = 'translateY(-100%)';
        setTimeout(() => {
          banner.style.display = 'none';
          // Ajustar padding del body
          document.body.style.paddingTop = '20px';
        }, 500);
      }
      
      // Habilitar selectores
      const selectProblem = document.getElementById('selectProblem');
      const selectInput = document.getElementById('selectInput');
      const selectLanguage = document.getElementById('selectLanguage');
      const btnRefreshProblems = document.getElementById('btnRefreshProblems');
      
      if (selectProblem) selectProblem.disabled = false;
      if (selectInput) selectInput.disabled = false;
      if (selectLanguage) selectLanguage.disabled = false;
      if (btnRefreshProblems) btnRefreshProblems.disabled = false;
      
      // Habilitar editores
      const codeCm = document.getElementById('code-cm');
      if (codeCm) codeCm.disabled = false;
      
      // Si Monaco est√° cargado, habilitarlo
      if (typeof monacoEditor !== 'undefined' && monacoEditor) {
        monacoEditor.updateOptions({ readOnly: false });
      }
      
      // Habilitar botones Judge0 y Oficial (siempre disponibles)
      const btnJudge0 = document.getElementById('btnJudge0');
      const btnOfficial = document.getElementById('btnOfficial');
      
      if (btnJudge0) {
        btnJudge0.disabled = false;
        btnJudge0.title = '';
      }
      if (btnOfficial) {
        btnOfficial.disabled = false;
        btnOfficial.title = '';
      }
      
      // Para los botones de sandbox, solo habilitar si el sandbox est√° disponible
      // (esto lo maneja la l√≥gica existente de checkSandbox)
      // Los botones de descarga se pueden habilitar siempre
      const btnDownloadSandbox = document.getElementById('btnDownloadSandbox');
      const btnDownloadDotnet = document.getElementById('btnDownloadDotnet');
      
      if (btnDownloadSandbox) {
        btnDownloadSandbox.disabled = false;
        btnDownloadSandbox.title = 'üì• Descargar Sandbox';
      }
      if (btnDownloadDotnet) {
        btnDownloadDotnet.disabled = false;
        btnDownloadDotnet.title = '‚¨áÔ∏è Descargar .NET 10 SDK';
      }
      
      // Nota: btnSandbox, btnValidation y btnClearDataset se habilitar√°n
      // autom√°ticamente por la funci√≥n enableSandboxButtons() si el sandbox est√° disponible
      
      // Habilitar tabs de editor
      const tabCm = document.getElementById('tab-cm');
      const tabMonaco = document.getElementById('tab-monaco');
      if (tabCm) tabCm.style.pointerEvents = 'auto';
      if (tabMonaco) tabMonaco.style.pointerEvents = 'auto';
      
      // Mostrar mensaje de √©xito
      showMessage('‚úÖ ¬°Bienvenido! Ya puedes usar todas las funciones del Juez Virtual.', 'ok');
    }

    // BOOKMARK: Inicializaci√≥n del sandbox al cargar p√°gina
    // Verificar si el sandbox est√° disponible al cargar la p√°gina
    window.addEventListener('DOMContentLoaded', async () => {
      console.log('üöÄ P√°gina cargada, iniciando verificaci√≥n del sandbox...');
      
      // 1. PRIMERO: Verificar si el sandbox est√° habilitado en la configuraci√≥n del servidor
      try {
        console.log('üîç Verificando configuraci√≥n del servidor...');
        const configRes = await fetch('/api/sandbox-enabled');
        
        if (!configRes.ok) {
          console.error('‚ùå Error al obtener configuraci√≥n del servidor:', configRes.status);
          disableSandboxByConfiguration();
          return;
        }
        
        const configData = await configRes.json();
        console.log('üìã Configuraci√≥n del servidor:', configData);
        
        if (!configData.enabled) {
          console.log('‚ö†Ô∏è Sandbox deshabilitado por configuraci√≥n:', configData.message);
          disableSandboxByConfiguration();
          return;
        }
        
        console.log('‚úÖ Sandbox habilitado en configuraci√≥n del servidor');
      } catch (error) {
        console.error('‚ùå Error al verificar configuraci√≥n del servidor:', error);
        disableSandboxByConfiguration();
        return;
      }
      
      // 2. SEGUNDO: Detectar sistema operativo
      const os = detectOS();
      isWindows64 = os.isWindows64;
      console.log(`üíª Sistema detectado: ${os.osName} ${os.is64bit ? '64-bit' : '32-bit'}`);
      
      // Si no es Windows 64 bits, deshabilitar sandbox y mostrar mensaje
      if (!isWindows64) {
        console.log('‚ö†Ô∏è Sistema NO compatible con el sandbox local (requiere Windows x64)');
        disableSandboxForIncompatibleOS(os.osName);
        return;
      }
      
      // 3. TERCERO: Verificar disponibilidad del sandbox (ping)
      await checkAndPromptSandbox();
      console.log('‚úÖ Verificaci√≥n inicial del sandbox completada');
      
      // 3.1 Mostrar informaci√≥n sobre el sandbox local si est√° habilitado
      showSandboxInfoIfEnabled();
      
      // 4. CUARTO: Deshabilitar todos los controles hasta que el estudiante se registre
      disableAllControlsForRegistration();
      console.log('üîí Controles deshabilitados - Esperando selecci√≥n de estudiante');
    });

    // BOOKMARK: Verificar si el sandbox responde (sin UI)
    async function pingSandbox() {
      try {
        console.log(`üì° Intentando ping a: ${SANDBOX_BASE}/ping`);
        const res = await fetch(`${SANDBOX_BASE}/ping`, {
          method: 'GET',
          signal: AbortSignal.timeout(2000)
        });
        
        console.log(`üì° Respuesta ping: status=${res.status}, ok=${res.ok}`);
        if (!res.ok) return false;
        
        // Verificar que responda con el mensaje esperado
        const text = await res.text();
        console.log(`üì° Texto respuesta ping: "${text}"`);
        const isValid = text.includes('Sandbox activo') || text.includes('‚úÖ');
        console.log(`üì° Ping v√°lido: ${isValid}`);
        return isValid;
      } catch (err) {
        console.log(`‚ùå Error en ping: ${err.message}`);
        return false;
      }
    }

    // bookamark: Habilitar botones del sandbox (y tambi√©n Judge0 y Oficial)
    function enableSandboxButtons() {
      const btnSandbox = document.getElementById('btnSandbox');
      const btnValidation = document.getElementById('btnValidation');
      const btnClearDataset = document.getElementById('btnClearDataset');
      const btnJudge0 = document.getElementById('btnJudge0');
      const btnOfficial = document.getElementById('btnOfficial');
      
      sandboxAvailable = true;
      btnSandbox.disabled = false;
      btnValidation.disabled = false;
      btnClearDataset.disabled = false;
      btnJudge0.disabled = false;
      btnOfficial.disabled = false;
      btnSandbox.title = 'Sandbox local disponible';
      btnValidation.title = 'Sandbox local disponible';
      btnClearDataset.title = 'Limpiar el dataset del problema actual';
      btnJudge0.title = '';
      btnOfficial.title = '';
      btnSandbox.textContent = 'üß™ Probar en Sandbox';
      btnValidation.textContent = 'üìÇ Validar con DataSet local';
      
      console.log('‚úÖ Sandbox local disponible - Todos los botones habilitados');
      
      // Detener el chequeo peri√≥dico
      if (checkInterval) {
        clearInterval(checkInterval);
        checkInterval = null;
      }
    }

    // BOOKMARK: Deshabilitar sandbox por sistema operativo incompatible
    function disableSandboxForIncompatibleOS(osName) {
      const btnSandbox = document.getElementById('btnSandbox');
      const btnValidation = document.getElementById('btnValidation');
      const btnDownloadSandbox = document.getElementById('btnDownloadSandbox');
      const btnDownloadDotnet = document.getElementById('btnDownloadDotnet');
      
      const message = `‚ùå No disponible en ${osName}`;
      const tooltip = `El sandbox local solo funciona en Windows 64 bits. Tu sistema: ${osName}`;
      
      // Deshabilitar botones del sandbox
      btnSandbox.disabled = true;
      btnValidation.disabled = true;
      btnDownloadSandbox.disabled = true;
      btnDownloadDotnet.disabled = true;
      
      btnSandbox.textContent = message;
      btnValidation.textContent = message;
      btnSandbox.title = tooltip;
      btnValidation.title = tooltip;
      btnDownloadSandbox.title = tooltip;
      btnDownloadDotnet.title = tooltip;
      
      // Cambiar color a gris para indicar deshabilitado
      btnDownloadSandbox.style.backgroundColor = '#cccccc';
      btnDownloadDotnet.style.backgroundColor = '#cccccc';
      
      sandboxAvailable = false;
      
      console.log(`üö´ Sandbox deshabilitado: Sistema incompatible (${osName})`);
      
      // Mostrar mensaje informativo al usuario
      setTimeout(() => {
        alert(
          `‚ö†Ô∏è SANDBOX LOCAL NO DISPONIBLE\n\n` +
          `Tu sistema operativo: ${osName}\n` +
          `Requerido: Windows 64 bits\n\n` +
          `üìù Puedes seguir usando:\n` +
          `‚Ä¢ Juez de Prueba (Judge0)\n` +
          `‚Ä¢ Juez Oficial (para calificaci√≥n)\n\n` +
          `üí° El sandbox local es opcional y solo est√° disponible en Windows x64.`
        );
      }, 1000);
    }

    // BOOKMARK: Deshabilitar botones del sandbox (y tambi√©n Judge0 y Oficial durante validaci√≥n)
    function disableSandboxButtons(message) {
      const btnSandbox = document.getElementById('btnSandbox');
      const btnValidation = document.getElementById('btnValidation');
      const btnClearDataset = document.getElementById('btnClearDataset');
      const btnJudge0 = document.getElementById('btnJudge0');
      const btnOfficial = document.getElementById('btnOfficial');
      
      sandboxAvailable = false;
      btnSandbox.disabled = true;
      btnValidation.disabled = true;
      btnClearDataset.disabled = true;
      btnJudge0.disabled = true;
      btnOfficial.disabled = true;
      btnSandbox.title = message;
      btnValidation.title = message;
      btnJudge0.title = message;
      btnOfficial.title = message;
      btnSandbox.textContent = message;
      btnValidation.textContent = message;
      
      console.log(`üîí Todos los botones deshabilitados: ${message}`);
    }

    // BOOKMARK: Monitoreo peri√≥dico del sandbox cada 5 segundos
    // Iniciar verificaci√≥n peri√≥dica del sandbox
    function startSandboxMonitoring() {
      if (checkInterval) return; // Ya est√° monitoreando
      
      console.log('üîÑ Iniciando monitoreo del sandbox (cada 5 segundos)...');
      
      checkInterval = setInterval(async () => {
        const isAlive = await pingSandbox();
        if (isAlive) {
          console.log('‚úÖ Sandbox detectado corriendo!');
          enableSandboxButtons();
        }
      }, 5000); // Verificar cada 5 segundos
    }

    // BOOKMARK: Verificaci√≥n inicial y descarga del sandbox
    // Verificar sandbox y ofrecer descarga si no est√°
    async function checkAndPromptSandbox() {
      console.log('üîç Iniciando verificaci√≥n del sandbox...');
      const btnSandbox = document.getElementById('btnSandbox');
      const btnValidation = document.getElementById('btnValidation');
      
      // SIEMPRE verificar primero si el sandbox est√° corriendo (ping)
      console.log('üì° Haciendo ping al sandbox...');
      const isAlive = await pingSandbox();
      
      if (isAlive) {
        console.log('‚úÖ Sandbox detectado activo!');
        enableSandboxButtons();
        return;
      }

      console.log('‚ùå Sandbox NO responde al ping');

      // Si no est√° activo, verificar si ya se descarg√≥ previamente
      const alreadyDownloaded = localStorage.getItem('sandboxDownloaded');
      console.log('üíæ LocalStorage sandboxDownloaded:', alreadyDownloaded);
      
      if (alreadyDownloaded) {
        // Ya se descarg√≥, solo esperar que se ejecute
        console.log('‚è≥ Sandbox ya fue descargado, esperando que se ejecute...');
        btnSandbox.title = 'Esperando que ejecutes el sandbox local...';
        btnValidation.title = 'Esperando que ejecutes el sandbox local...';
        startSandboxMonitoring(); // Iniciar monitoreo autom√°tico
        return;
      }

      // Sandbox no disponible y no descargado, preguntar al usuario
      console.log('üí¨ Mostrando prompt de descarga al usuario...');
      const download = confirm(
        'üîß El Sandbox local no est√° disponible.\n\n' +
        '¬øDeseas descargar DotNetInteractiveServer.zip desde Google Drive?\n\n' +
        'üì¶ Se descargar√° desde Google Drive (no consume ancho de banda del servidor)\n' +
        '‚ö†Ô∏è Solo para Windows x64 con .NET SDK 10\n\n' +
        '(La descarga comenzar√° autom√°ticamente si aceptas)'
      );

      if (download) {
        console.log('‚úÖ Usuario acept√≥ descargar el sandbox');
        await downloadSandbox();
      } else {
        console.log('‚ùå Usuario rechaz√≥ la descarga');
        btnSandbox.title = 'Sandbox no disponible. Usa el bot√≥n "üì• Descargar Sandbox" si cambias de opini√≥n.';
        btnValidation.title = 'Sandbox no disponible. Usa el bot√≥n "üì• Descargar Sandbox" si cambias de opini√≥n.';
        // Iniciar monitoreo de todas formas por si el usuario lo ejecuta manualmente
        startSandboxMonitoring();
      }
    }

    // Mostrar informaci√≥n sobre el sandbox local si est√° habilitado en configuraci√≥n
    async function showSandboxInfoIfEnabled() {
      try {
        const configRes = await fetch('/api/sandbox-enabled');
        if (!configRes.ok) return;
        
        const configData = await configRes.json();
        if (configData.enabled) {
          // Crear y mostrar mensaje informativo discreto
          const infoDiv = document.createElement('div');
          infoDiv.id = 'sandbox-info-banner';
          infoDiv.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 9999;
            max-width: 400px;
            font-size: 13px;
            line-height: 1.5;
            animation: slideIn 0.5s ease-out;
          `;
          
          infoDiv.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
              <strong style="font-size: 14px;">‚ÑπÔ∏è Sandbox Local Autorizado para ser utilizado</strong>
              <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; color: white; font-size: 18px; cursor: pointer; padding: 0; margin-left: 10px;">&times;</button>
            </div>
            <div style="font-size: 12px; opacity: 0.95;">
              ‚ö†Ô∏è <strong>Importante:</strong>Si as√≠ lo deseas, levanta el Sandbox local y si tu navegador te pide permiso porque "Cloudflare quiere comunicarse con dispositivos de tu red local", debes <strong>ACEPTAR</strong>.<br><br>
              üìã <strong>Requisitos para usar Sandbox local:</strong><br>
              ‚Ä¢ Seleccionar tu nombre de estudiante<br>
              ‚Ä¢ Seleccionar un problema<br>
              ‚Ä¢ El dataset del problema debe estar descargado<br><br>
              <small style="opacity: 0.8;">üí° El sistema verifica autom√°ticamente estos requisitos.</small>
            </div>
          `;
          
          // Agregar al body
          document.body.appendChild(infoDiv);
          
          // Agregar animaci√≥n
          const style = document.createElement('style');
          style.textContent = `
            @keyframes slideIn {
              from {
                transform: translateX(100%);
                opacity: 0;
              }
              to {
                transform: translateX(0);
                opacity: 1;
              }
            }
          `;
          document.head.appendChild(style);
          
          // Auto-ocultar despu√©s de 15 segundos
          setTimeout(() => {
            if (infoDiv.parentElement) {
              infoDiv.style.transition = 'opacity 0.5s, transform 0.5s';
              infoDiv.style.opacity = '0';
              infoDiv.style.transform = 'translateX(100%)';
              setTimeout(() => infoDiv.remove(), 500);
            }
          }, 15000);
        }
      } catch (error) {
        console.log('No se pudo verificar configuraci√≥n del sandbox:', error);
      }
    }

    // Descargar el sandbox desde Google Drive
    async function downloadSandbox() {
      const btnSandbox = document.getElementById('btnSandbox');
      const btnValidation = document.getElementById('btnValidation');
      
      btnSandbox.textContent = '‚è≥ Descargando sandbox...';
      btnValidation.textContent = '‚è≥ Descargando sandbox...';

      try {
        // Crear enlace de descarga desde Google Drive (nuevo formato)
        const a = document.createElement('a');
        a.href = SANDBOX_DOWNLOAD_URL;
        a.target = '_blank';  // Abrir en nueva pesta√±a por si Google Drive pide confirmaci√≥n
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

        // Marcar como descargado en localStorage
        localStorage.setItem('sandboxDownloaded', 'true');

        // Mostrar instrucciones
        alert(
          '‚úÖ Descarga iniciada: DotNetInteractiveServer.zip (desde Google Drive)\n\n' +
          'üìù Instrucciones:\n' +
          '1. Si Google Drive pide confirmaci√≥n, haz clic en "Descargar de todas formas"\n' +
          '2. Extrae el archivo ZIP descargado\n' +
          '3. Ejecuta DotNetInteractiveServer.exe (solo Windows x64)\n' +
          '4. ‚ö†Ô∏è IMPORTANTE: Si el navegador pide permiso para que "Cloudflare quiere comunicarse con dispositivos de tu red local", debes ACEPTAR\n' +
          '5. Los botones se habilitar√°n autom√°ticamente cuando detecte el sandbox\n\n' +
          'üí° Esta p√°gina verificar√° cada 5 segundos si el sandbox est√° disponible.\n' +
          '‚ö†Ô∏è Requiere .NET SDK 10 instalado (usa el bot√≥n de descarga si no lo tienes).'
        );

        btnSandbox.textContent = 'üß™ Probar en Sandbox';
        btnValidation.textContent = 'üìÇ Validar con DataSet local';
        btnSandbox.title = 'Esperando que ejecutes el sandbox local...';
        btnValidation.title = 'Esperando que ejecutes el sandbox local...';

        // Iniciar monitoreo autom√°tico
        startSandboxMonitoring();

      } catch (err) {
        console.error('Error al descargar sandbox:', err);
        alert(
          '‚ùå Error al iniciar la descarga del sandbox.\n\n' +
          'Intenta descargar manualmente desde:\n' +
          `${SANDBOX_DOWNLOAD_URL}`
        );
        btnSandbox.textContent = 'üß™ Probar en Sandbox';
        btnValidation.textContent = 'üìÇ Validar con DataSet local';
      }
    }

    // Descargar .NET 10 SDK desde Google Drive
    function downloadDotnetSDK() {
      try {
        // ID del archivo en Google Drive: 1Rc1bcBnXDuv15x1MjDNhGZgwz4Byg5es
        // URL directa de descarga
        const fileId = '1Rc1bcBnXDuv15x1MjDNhGZgwz4Byg5es';
        const downloadUrl = `https://drive.google.com/uc?export=download&id=${fileId}`;
        
        // Crear enlace de descarga
        const a = document.createElement('a');
        a.href = downloadUrl;
        a.target = '_blank';  // Abrir en nueva pesta√±a por si Google Drive pide confirmaci√≥n
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

        // Mostrar instrucciones
        alert(
          '‚úÖ Descarga iniciada: .NET 10 SDK (Windows x64)\n\n' +
          '‚ö†Ô∏è IMPORTANTE:\n' +
          '‚Ä¢ Este instalador es SOLO para Windows 64 bits\n' +
          '‚Ä¢ NO es necesario si ya tienes .NET SDK 10 instalado\n' +
          '‚Ä¢ Verifica con: dotnet --version (debe ser 10.x.x)\n\n' +
          'üìù Si necesitas instalarlo:\n' +
          '1. Ejecuta el instalador descargado\n' +
          '2. Reinicia tu terminal o IDE si es necesario\n' +
          '3. Verifica con: dotnet --version\n\n' +
          'üí° El sandbox local requiere .NET SDK 10 o superior.\n' +
          'üîó Para otros sistemas operativos: https://dotnet.microsoft.com/download'
        );

      } catch (err) {
        console.error('Error al descargar .NET SDK:', err);
        alert('‚ùå Error al iniciar la descarga. Intenta nuevamente o descarga desde:\nhttps://drive.google.com/file/d/1Rc1bcBnXDuv15x1MjDNhGZgwz4Byg5es/view');
      }
    }

    // BOOKMARK: Gesti√≥n de datasets - sincronizaci√≥n incremental
    // Obtiene del sandbox lo ya instalado
    async function getInstalledDataset(problemId) {
      const res = await fetch(`${SANDBOX_BASE}/datasets/${encodeURIComponent(problemId)}`);
      if (!res.ok) throw new Error(`Sandbox no responde datasets (${res.status})`);
      return await res.json(); // { installed, inputs[], expected[] }
    }

    // Obtiene del servidor las listas oficiales
    async function getServerLists(problemId) {
      console.log(`üìã Obteniendo listas del servidor para problema ${problemId}...`);
      try {
        const [ri, re] = await Promise.all([
          fetch(`/problems/${problemId}/inputs`),
          fetch(`/problems/${problemId}/expected`)
        ]);
        
        if (!ri.ok) throw new Error(`No se pudieron listar inputs (status ${ri.status})`);
        
        const inputs = await ri.json();
        console.log(`üì• Inputs encontrados:`, inputs);
        
        let expected = [];
        if (re.ok) {
          expected = await re.json();
          console.log(`üì• Expected encontrados:`, expected);
        } else {
          console.log(`‚ö†Ô∏è No hay outputs esperados (status ${re.status})`);
        }
        
        return { inputs, expected };
      } catch (err) {
        console.error('‚ùå Error obteniendo listas del servidor:', err);
        throw err;
      }
    }

    // Descarga contenido de un archivo del servidor
    async function fetchServerFile(problemId, kind /* "input"|"expected" */, fileName) {
      const route = kind === "input" 
        ? `/problems/${problemId}/input/${fileName}`
        : `/problems/${problemId}/expected/${fileName}`;
      
      console.log(`üì• Descargando archivo: ${route}`);
      const res = await fetch(route);
      if (!res.ok) throw new Error(`No se pudo descargar ${fileName} (status ${res.status})`);
      return await res.text();
    }

    // BOOKMARK: Sincronizar DataSet. Sube SOLO lo que falta
    // Flag global para saber si el problema tiene validador
    let problemHasValidator = {};
    async function syncDataset(problemId) {
      console.log(`üîÑ Iniciando sincronizaci√≥n para problema ${problemId}...`);
      
      // Deshabilitar botones del sandbox durante la sincronizaci√≥n
      disableSandboxButtons("‚è≥ Sincronizando...");
      
      // Obtener referencia al √°rea de output
      const outputDiv = document.getElementById('output');
      if (outputDiv) {
        outputDiv.innerHTML = '<div style="color: #007bff; font-weight: bold;">üîÑ Iniciando sincronizaci√≥n del dataset...</div>';
      }
      
      try {
        // 1) Preguntar al sandbox qu√© ya tiene
        console.log(`üì° Consultando al sandbox qu√© archivos ya tiene...`);
        if (outputDiv) outputDiv.innerHTML = '<div>üì° Verificando archivos instalados en sandbox...</div>';
        const installed = await getInstalledDataset(problemId);
        console.log(`üì¶ Sandbox tiene:`, installed);

        // 2) Preguntar al servidor qu√© deber√≠a tener
        console.log(`üì° Consultando al servidor qu√© archivos deber√≠a tener...`);
        if (outputDiv) outputDiv.innerHTML = '<div>üì° Consultando archivos disponibles en servidor...</div>';
        const server = await getServerLists(problemId);

        // 3) Calcular faltantes
        const installedInputs   = new Set(installed.inputs ?? []);
        const installedExpected = new Set(installed.expected ?? []);
        const missingInputs   = server.inputs.filter(f => !installedInputs.has(f));
        const missingExpected = server.expected.filter(f => !installedExpected.has(f));

        console.log(`üìä Archivos faltantes - Inputs: ${missingInputs.length}, Expected: ${missingExpected.length}`);

        if (missingInputs.length === 0 && missingExpected.length === 0) {
          console.log(`‚úÖ ${problemId}: DataSet ya est√° completo`);
          if (outputDiv) outputDiv.innerHTML = '<div style="color: #28a745; font-weight: bold;">‚úÖ Dataset ya est√° completo</div>';
          return { uploaded: 0 };
        }

        // 4) Descargar solo faltantes y armar payload
        // -------------------------------------------------------------
        // Construcci√≥n del array 'files' que se enviar√° al sandbox:
        //
        //   files = [
        //     { path: 'DataSet/input1.txt', content: '...contenido...' },
        //     { path: 'DataSet/input2.txt', content: '...contenido...' },
        //     { path: '.Expected/output1.txt', content: '...contenido...' },
        //     ...
        //   ]
        //
        // Diagrama de flujo:
        //
        //   +-------------------+         +-------------------+
        //   |  missingInputs[]   |         | missingExpected[] |
        //   +-------------------+         +-------------------+
        //            |                           |
        //            v                           v
        //   for cada input:                for cada expected:
        //     fetch contenido                fetch contenido
        //     files.push({                   files.push({
        //       path: 'DataSet/...'            path: '.Expected/...'
        //       content: ...                  content: ...
        //     })                            })
        //            |                           |
        //            +-----------+   +-----------+
        //                        v   v
        //                  files[] final
        // -------------------------------------------------------------
        const files = [];
        const totalFiles = missingInputs.length + missingExpected.length;
        let downloadedCount = 0;

        if (outputDiv) outputDiv.innerHTML = `<div style="color: #17a2b8;">‚¨áÔ∏è Descargando archivos... (0/${totalFiles})</div>`;

        // --- Inputs ---
        console.log(`‚¨áÔ∏è Descargando ${missingInputs.length} inputs faltantes...`);
        for (const f of missingInputs) {
          downloadedCount++;
          if (outputDiv) outputDiv.innerHTML = `<div style="color: #17a2b8;">üì• Descargando archivo ${downloadedCount}/${totalFiles}: ${f}</div>`;
          const content = await fetchServerFile(problemId, "input", f);
          // Agrega el archivo al array con su ruta y contenido
          files.push({ path: `DataSet/${f}`, content });
        }

        // --- Expected outputs ---
        console.log(`‚¨áÔ∏è Descargando ${missingExpected.length} expected faltantes...`);
        for (const f of missingExpected) {
          downloadedCount++;
          if (outputDiv) outputDiv.innerHTML = `<div style="color: #17a2b8;">üì• Descargando archivo ${downloadedCount}/${totalFiles}: ${f}</div>`;
          const content = await fetchServerFile(problemId, "expected", f);
          // Agrega el archivo al array con su ruta y contenido
          files.push({ path: `.Expected/${f}`, content });
        }

        // 4.5) Intentar agregar validador si existe
        try {
          const validatorRes = await fetch(`/problems/${problemId}/validator`);
          if (validatorRes.ok) {
            const validator = await validatorRes.json();
            // Agregar Validator.cs y Solution.csproj en carpeta Validator/
            files.push({ path: `Validator/${validator.fileName}`, content: validator.content });
            files.push({ path: `Validator/${validator.csprojName}`, content: validator.csproj });
            problemHasValidator[problemId] = true;
            console.log('‚úÖ Validador agregado al dataset');
          } else {
            problemHasValidator[problemId] = false;
            console.log('‚ÑπÔ∏è No hay validador para este problema');
          }
        } catch (e) {
          problemHasValidator[problemId] = false;
          console.log('‚ö†Ô∏è Error al intentar agregar validador:', e);
        }

        // 5) Enviar al sandbox
        console.log(`üì§ Enviando ${files.length} archivos al sandbox...`);
        if (outputDiv) outputDiv.innerHTML = `<div style="color: #17a2b8;">üì§ Enviando ${files.length} archivos al sandbox...</div>`;
        await sendDatasetToSandbox(problemId, files);
        console.log(`‚úÖ Sincronizaci√≥n completada: ${files.length} archivos subidos`);
        if (outputDiv) outputDiv.innerHTML = `<div style="color: #28a745; font-weight: bold;">‚úÖ Sincronizaci√≥n completada: ${files.length} archivos sincronizados</div>`;
        return { uploaded: files.length };
      } catch (err) {
        console.error(`‚ùå Error en syncDataset para ${problemId}:`, err);
        if (outputDiv) outputDiv.innerHTML = `<div style="color: #dc3545; font-weight: bold;">‚ùå Error: ${err.message}</div>`;
        throw err;
      } finally {
        // Solo rehabilitar botones si NO estamos en medio de una validaci√≥n
        if (!isValidating) {
          enableSandboxButtons();
        }
      }
    }

    // ‚ÄúEnsure‚Äù: si no est√° completo, sincroniza; si est√°, no hace nada
    async function ensureDatasetInstalled(problemId) {
      try {
        const res = await syncDataset(problemId);
        if (res.uploaded === 0) {
          console.log(`‚úÖ ${problemId}: ya estaba instalado`);
        }
      } catch (err) {
        console.error("Error al asegurar dataset:", err);
        alert("‚ùå No se pudo asegurar el DataSet en el sandbox.");
      }
    }

    // BOOKMARK: Ejecuci√≥n de c√≥digo en sandbox local
    // üîπ Ejecutar el c√≥digo en el sandbox local
    async function runLocalCode() {
      const output = document.getElementById("output");
      
      // Verificar si el lenguaje es C++
      const selectedLang = document.getElementById("selectLanguage").value;
      if (selectedLang === "cpp") {
        output.textContent = "‚ö†Ô∏è El sandbox local no soporta C++ por el momento.\n\nPor favor, utiliza:\n‚Ä¢ Juez de Prueba (Judge0)\n‚Ä¢ Juez Oficial";
        output.className = "result warn";
        return;
      }
      
      output.textContent = "‚è≥ Ejecutando c√≥digo en el sandbox local...\n";

      const raw = getCurrentCode();
      const code = normalizeCodeForKernel(raw);
      console.log("C√≥digo enviado =>", code);

      if (!code.trim()) {
        output.textContent = "‚ö†Ô∏è No hay c√≥digo para ejecutar.";
        return;
      }

      // Obtener el stdin del textarea
      const stdin = document.getElementById('stdin').value;

      try {
        // BOOKMARK: Ejecutar execute con c√≥digo y stdin en el sandbox
        const log = document.getElementById("validationLog");
        log.textContent = "‚úÖ C√≥digo ejecutado, esperando respuesta...\n";
        
        const res = await fetch(`${SANDBOX_URL}/execute`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            code: code,
            stdin: stdin  // ‚ú® El sandbox acepta stdin
          }),
        });

        log.textContent = "";

        if (!res.ok) throw new Error(`Error HTTP ${res.status}`);

        const data = await res.json();
        console.log("Respuesta del sandbox:", data);

        // El servidor devuelve { output: "..." }
        const outputText = data.output || "";

        output.textContent =
          "üñ•Ô∏è Salida del programa:\n\n" +
          (outputText.trim() || "(sin salida)");
      } catch (err) {
        console.error(err);
        output.textContent =
          "‚ùå No se pudo conectar al sandbox local.\n" +
          "Aseg√∫rate de haber ejecutado DotNetInteractiveServer.exe.\n\n" +
          err.message;
      }
    }

    // Normaliza la declaraci√≥n de Main para que no tenga espacios ni ENTERs extra
    function normalizeCodeForKernel(sourceCode) {
      // Eliminar namespace y llaves externas en pasos separados
      let code = sourceCode;
      // Paso 1: Eliminar l√≠nea de namespace y la primera llave de apertura
      const nsLine = code.match(/namespace\s+\w+[\s\r\n]*\{/);
      if (nsLine) {
        code = code.replace(/namespace\s+\w+[\s\r\n]*\{/, '');
        // Paso 2: Eliminar la √∫ltima llave de cierre (})
        const lastBrace = code.lastIndexOf('}');
        if (lastBrace !== -1) {
          code = code.substring(0, lastBrace) + code.substring(lastBrace + 1);
        }
      }
      // Normalizar declaraci√≥n de Main (siempre)
      const mainRegex = /(public\s+)?static\s+(async\s+)?(Task|void)\s+Main\s*\([^)]*\)\s*\{/g;
      code = code.replace(mainRegex, (match) => {
        let normalized = match.replace(/\s+/g, ' ');
        normalized = normalized.replace(/\s*\(/, '(').replace(/\s*\{/, '{');
        return normalized;
      });
      return code;
    }
    
    // Extrae todas las variantes de Main encontradas (para debug o validaci√≥n extra)
    function extractAllMainVariants(sourceCode) {
      const mainRegex = /(public\s+)?static\s+(async\s+)?(Task|void)\s+Main\s*\([^)]*\)\s*\{/g;
      let result = [];
      let match;
      while ((match = mainRegex.exec(sourceCode)) !== null) {
        result.push({ index: match.index, declaration: match[0] });
      }
      return result;
    }

    // --- VERSI√ìN ANTERIOR (comentada, por compatibilidad/hist√≥rico) ---
    /*
    function normalizeCodeForKernel(sourceCode) {
      // El Sandbox, ya deber√≠a soportar el cpdoigo sin ncesidad de normalizarlo; salvo que
      // env√≠en c√≥digo donde la funci√≥n Main, no pertenezca a una clase llamada Program
      return sourceCode;
      // ...versi√≥n anterior eliminando class Program y Main...
    }
    */
  </script>

  <script>
    // BOOKMARK: Validaci√≥n offline con datasets locales
    // üîπ Validar el c√≥digo con datasets del sandbox
    // Usuario hace clic en "Validar" 
    //    ‚Üí Se deshabilitan TODOS los botones (excepto Cancelar)
    //    ‚Üí Se verifica/sincroniza dataset (sin habilitar botones)
    //    ‚Üí Se ejecuta validaci√≥n
    //    ‚Üí Al terminar/error ‚Üí Se habilitan todos los botones
    //    ‚Üí Se oculta bot√≥n "Cancelar"
    async function runOfflineValidation() {
      const log = document.getElementById("validationLog");
      const output = document.getElementById("output");
      
      
      // Verificar si el lenguaje es C++
      const selectedLang = document.getElementById("selectLanguage").value;
      if (selectedLang === "cpp") {
        output.textContent = "‚ö†Ô∏è La validaci√≥n con sandbox local no soporta C++ por el momento.\n\nPor favor, utiliza:\n‚Ä¢ Juez de Prueba (Judge0)\n‚Ä¢ Juez Oficial";
        output.className = "result warn";
        log.textContent = "";
        return;
      }
      
      // Obtener el problema actual
      const problemId = document.getElementById("txtProblemId").value;
      
      if (!problemId) {
        output.textContent = "‚ö†Ô∏è Selecciona un problema primero.";
        output.className = "result warn";
        return;
      }

      const code = getCurrentCode();
      if (!code.trim()) {
        output.textContent = "‚ö†Ô∏è No hay c√≥digo para validar.";
        output.className = "result warn";
        return;
      }

      log.textContent = "üìÇ Preparando validaci√≥n con DataSet local del sandbox...\n";
      output.textContent = "‚è≥ Validando...";
      output.className = "result warn";

      // Deshabilitar botones del sandbox durante la validaci√≥n
      disableSandboxButtons("‚è≥ Validando...");
      isValidating = true;
      
      // Mostrar bot√≥n de cancelar
      const btnCancel = document.getElementById('btnCancelValidation');
      if (btnCancel) btnCancel.style.display = 'inline-block';
      
      // Crear AbortController para poder cancelar
      validationAbortController = new AbortController();

      try {
        console.log(`üß™ Validando problema ${problemId} con sandbox...`);
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PASO 1: Verificar si el dataset existe, si no, sincronizarlo autom√°ticamente
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        log.textContent += "üîç Verificando dataset...\n";
        console.log(`üîç Verificando dataset del problema ${problemId}...`);
        
        try {
          const installed = await getInstalledDataset(problemId);
          const hasInputs = installed.inputs && installed.inputs.length > 0;
          const hasExpected = installed.expected && installed.expected.length > 0;
          
          if (!hasInputs || !hasExpected) {
            console.log(`üì¶ Dataset no encontrado o incompleto, sincronizando...`);
            log.textContent += "üì¶ Dataset no encontrado o incompleto\n";
            log.textContent += "üîÑ Sincronizando dataset desde el servidor...\n";
            
            const syncResult = await syncDataset(problemId);
            
            if (syncResult.uploaded > 0) {
              log.textContent += `‚úÖ Dataset sincronizado: ${syncResult.uploaded} archivos descargados\n`;
              console.log(`‚úÖ Dataset sincronizado: ${syncResult.uploaded} archivos`);
            } else {
              log.textContent += "‚úÖ Dataset ya estaba completo\n";
            }
          } else {
            console.log(`‚úÖ Dataset ya disponible en sandbox`);
            log.textContent += "‚úÖ Dataset disponible\n";
          }

        } catch (syncError) {
          console.error('‚ùå Error al verificar/sincronizar dataset:', syncError);
          log.textContent += `‚ùå Error al preparar dataset: ${syncError.message}\n`;
          output.textContent = `‚ùå No se pudo preparar el dataset:\n${syncError.message}`;
          output.className = "result err";
          isValidating = false;  // ‚úÖ Ya terminamos de validar (error en sincronizaci√≥n)
          enableSandboxButtons();
          if (btnCancel) btnCancel.style.display = 'none';
          return;
        }
        
        log.textContent += "\nüìÇ Iniciando validaci√≥n...\n";

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BOOKMARK: STREAMING CON SERVER-SENTZ EVENTS (SSE)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Enviamos la petici√≥n al sandbox para validar el c√≥digo.
        // El servidor NO env√≠a una respuesta √∫nica, sino un STREAM continuo
        // de eventos (como un r√≠o de datos que va llegando de a poco).
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        fetch(`${SANDBOX_URL}/validate-dataset`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            'Accept': 'text/event-stream'  // ‚ú® Le decimos al servidor: "quiero streaming SSE"
          },
          body: JSON.stringify({
            code: normalizeCodeForKernel(code),
            problem: problemId,
            timeoutMs: 5000
          }),
          signal: validationAbortController.signal  // ‚ú® Permitir cancelaci√≥n
        }).then(response => {
          // Verificar que el servidor respondi√≥ correctamente
          if (!response.ok) {
            throw new Error(`Error HTTP ${response.status}`);
          }
          
          // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          // CONFIGURACI√ìN DEL LECTOR DE STREAM
          // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          // reader: Objeto que nos permite leer el stream de datos "chunk por chunk"
          //         (chunk = pedazo de datos que llega cada vez)
          const reader = response.body.getReader();
          validationReader = reader;  // ‚ú® Guardar para poder cancelar
          
          // decoder: Convierte bytes (n√∫meros) a texto legible
          const decoder = new TextDecoder();
          
          // buffer: Almacena texto incompleto entre chunks
          //         A veces un mensaje llega partido en 2 chunks, el buffer lo guarda
          let buffer = '';
          
          // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          // FUNCI√ìN RECURSIVA: processStream()
          // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          // Esta funci√≥n se llama a s√≠ misma para leer chunk tras chunk
          // hasta que el servidor termine de enviar datos.
          //
          // ¬øPor qu√© recursiva y no un loop?
          // Porque reader.read() es AS√çNCRONA (devuelve una promesa).
          // No podemos hacer: while(!done) { read(); } ‚Üê esto no funciona con async
          // En cambio: read().then(() => processStream()) ‚Üê esto S√ç funciona
          // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          function processStream() {
            // Leer el siguiente chunk del stream
            reader.read().then(({ done, value }) => {
              // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              // CASO 1: El stream termin√≥ (done = true)
              // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              if (done) {
                console.log('‚úÖ Stream completado - No hay m√°s datos del servidor');
                
                // Ocultar bot√≥n de cancelar (reutilizar variable del scope superior)
                if (btnCancel) btnCancel.style.display = 'none';
                
                // Limpiar referencias
                validationAbortController = null;
                validationReader = null;
                
                isValidating = false;  // ‚úÖ Ya terminamos de validar
                enableSandboxButtons();  // ‚úÖ Rehabilitar botones al terminar exitosamente
                return;  // üõë FIN DE LA RECURSI√ìN - La funci√≥n no se vuelve a llamar
              }
              
              // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              // CASO 2: Lleg√≥ un chunk de datos (value contiene bytes)
              // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              
              // 1Ô∏è‚É£ Convertir bytes a texto y agregarlo al buffer
              //    { stream: true } = "puede haber m√°s datos despu√©s"
              buffer += decoder.decode(value, { stream: true });
              
              // 2Ô∏è‚É£ Separar el buffer en l√≠neas (los eventos SSE vienen l√≠nea por l√≠nea)
              const lines = buffer.split('\n');
              
              // 3Ô∏è‚É£ Guardar la √∫ltima l√≠nea (puede estar incompleta)
              //    lines.pop() saca y devuelve el √∫ltimo elemento del array
              //    Si est√° vac√≠o, usamos '' (cadena vac√≠a)
              buffer = lines.pop() || '';
              
              // 4Ô∏è‚É£ Procesar cada l√≠nea completa
              //    Formato SSE:
              //    event: start
              //    data: {"totalCases": 5}
              //
              //    event: case-result
              //    data: {"caseNumber": 1, "result": "Accepted"}
              for (const line of lines) {
                // ¬øLa l√≠nea comienza con "event:"?
                if (line.startsWith('event:')) {
                  // Extraer el tipo de evento (ejemplo: "start", "case-result", "complete")
                  const eventType = line.substring(6).trim();  // substring(6) = omite "event:"
                  
                  // Buscar la siguiente l√≠nea que debe tener los datos (data:)
                  const dataLineIndex = lines.indexOf(line) + 1;
                  
                  // Verificar que existe la l√≠nea de datos
                  if (dataLineIndex < lines.length && lines[dataLineIndex].startsWith('data:')) {
                    // Extraer el JSON (omitiendo "data: ")
                    const jsonText = lines[dataLineIndex].substring(5).trim();
                    
                    // Convertir el texto JSON a un objeto JavaScript
                    const data = JSON.parse(jsonText);
                    
                    // üéØ Llamar a la funci√≥n que maneja el evento
                    //    (esta funci√≥n muestra los resultados en la UI)
                    handleSSEEvent(eventType, data);
                  }
                }
              }
              
              // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              // üîÑ RECURSI√ìN: Llamarse a s√≠ misma para leer el siguiente chunk
              // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              // Esta es la clave del streaming:
              // 1. Leemos un chunk
              // 2. Lo procesamos
              // 3. Llamamos a processStream() de nuevo para leer el siguiente
              // 4. Repetimos hasta que done=true
              //
              // Flujo visual:
              // Server ‚Üí [chunk1] ‚Üí processStream() ‚Üí procesa ‚Üí llama processStream()
              //                                                           ‚Üì
              // Server ‚Üí [chunk2] ‚Üí processStream() ‚Üí procesa ‚Üí llama processStream()
              //                                                           ‚Üì
              // Server ‚Üí [chunk3] ‚Üí processStream() ‚Üí procesa ‚Üí llama processStream()
              //                                                           ‚Üì
              // Server ‚Üí [done=true] ‚Üí processStream() ‚Üí return (fin)
              processStream();
              
            }).catch(streamErr => {
              // Si hay un error leyendo el stream, mostrarlo
              console.error('‚ùå Error en stream:', streamErr);
              
              // Ocultar bot√≥n de cancelar
              const btnCancel = document.getElementById('btnCancelValidation');
              if (btnCancel) btnCancel.style.display = 'none';
              
              // Limpiar referencias
              validationAbortController = null;
              validationReader = null;
              
              // Verificar si fue cancelado por el usuario
              if (streamErr.name === 'AbortError') {
                console.log('‚úÖ Stream cancelado correctamente');
                return;
              }
              
              log.textContent += `\n‚ùå Error en stream: ${streamErr.message}\n`;
              output.textContent = `‚ùå Error procesando resultados: ${streamErr.message}`;
              output.className = "result err";
              
              // Ocultar bot√≥n de cancelar y rehabilitar botones
              if (btnCancel) btnCancel.style.display = 'none';
              isValidating = false;  // ‚úÖ Ya terminamos de validar (con error)
              enableSandboxButtons();  // ‚úÖ Rehabilitar botones si hay error en el stream
            });
          }
          
          // üöÄ Primera llamada a processStream() para iniciar la lectura
          processStream();
        }).catch(err => {
          console.error('‚ùå Error en validaci√≥n:', err);
          log.textContent += `\n‚ùå Error: ${err.message}\n`;
          output.textContent = 
            "‚ùå No se pudo validar con el sandbox.\n" +
            "Aseg√∫rate de:\n" +
            "1. Tener el sandbox ejecut√°ndose\n" +
            "2. Haber sincronizado los datasets del problema\n\n" +
            err.message;
          output.className = "result err";
          
          // Ocultar bot√≥n de cancelar y rehabilitar botones
          if (btnCancel) btnCancel.style.display = 'none';
          isValidating = false;  // ‚úÖ Ya terminamos de validar (con error)
          enableSandboxButtons();  // ‚úÖ Rehabilitar botones si hay error en la petici√≥n
        });

      } catch (err) {
        console.error("Error en validaci√≥n:", err);
        
        // Ocultar bot√≥n de cancelar (reutilizar variable del scope superior)
        if (btnCancel) btnCancel.style.display = 'none';
        
        // Limpiar referencias
        validationAbortController = null;
        validationReader = null;
        
        log.textContent += `\n‚ùå Error: ${err.message}\n`;
        output.textContent = 
          "‚ùå No se pudo validar con el sandbox.\n" +
          "Aseg√∫rate de:\n" +
          "1. Tener el sandbox ejecut√°ndose\n" +
          "2. Haber sincronizado los datasets del problema\n\n" +
          err.message;
        output.className = "result err";
        isValidating = false;  // ‚úÖ Ya terminamos de validar (con error)
        enableSandboxButtons();  // ‚úÖ Rehabilitar botones si hay error en el try-catch
      }
    }

    // BOOKMARK: Manejo de eventos SSE del sandbox durante la validaci√≥n
    function handleSSEEvent(eventType, data) {
        const log = document.getElementById('validationLog');
        const output = document.getElementById('output');
        
        // Mostrar si se est√° usando validador (solo al inicio y durante los casos)
        let usingValidator = false;
        if (data && data.problem && problemHasValidator[data.problem]) {
          usingValidator = true;
        }
        if (eventType === 'start') {
          log.textContent = `üöÄ Iniciando validaci√≥n de ${data.totalCases} casos para problema ${data.problem}...\n`;
          if (usingValidator) {
            log.textContent += 'üõ°Ô∏è Usando validador especial para este problema\n\n';
          } else {
            log.textContent += '\n';
          }
          output.className = 'result';
          output.textContent = '';
        }
        else if (eventType === 'case-result') {
          const percent = Math.round((data.caseNumber / data.totalCases) * 100);
          // Actualizar output con progreso
          output.textContent = `‚è≥ Procesando caso ${data.caseNumber}/${data.totalCases} (${percent}%): ${data.caseName}`;
          // Agregar resultado al log
          const resultIcon = data.result === 'Accepted' ? '‚úÖ' : 
                    data.result === 'Wrong Answer' ? '‚ùå' : 
                    data.result === 'Error' ? '‚ö†Ô∏è' : '‚ùì';
          let resultLine = `${resultIcon} Caso ${data.caseNumber}/${data.totalCases}: ${data.caseName} ‚Üí ${data.result} (${data.timeMs}ms)\n`;
          if (data.diff) {
            resultLine += `   Diferencia:\n${data.diff}\n`;
          }
          log.textContent += resultLine;
          // Auto-scroll al final del log
          log.scrollTop = log.scrollHeight;
        }
        else if (eventType === 'complete') {
          output.textContent = `‚úÖ Validaci√≥n completada - ${data.totalCases} casos procesados`;
          output.className = 'result ok';
          log.textContent += `\n‚úÖ Validaci√≥n completada - ${data.totalCases} casos procesados\n`;
        }
      }

    // BOOKMARK: Env√≠o de datasets al sandbox
    // ----------------------------------------------------------------------
    //  Enviar dataset al sandbox local
    // ----------------------------------------------------------------------
    async function sendDatasetToSandbox(problemId, files) {
      try {
        const res = await fetch(SANDBOX_BASE + "/upload-dataset", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ problemId, files }),
        });

        if (!res.ok) throw new Error(`Error HTTP ${res.status}`);
        const data = await res.json();
        console.log("Sandbox respondi√≥:", data);

        if (data.ok) {
          alert(`‚úÖ DataSet ${data.problem} instalado (${data.saved} archivos).`);
        } else {
          alert("‚ö†Ô∏è No se pudo instalar el DataSet.");
        }
      } catch (err) {
        console.error("Error enviando DataSet:", err);
        alert("‚ùå No se pudo enviar el DataSet al sandbox local.");
      }
    }

    // BOOKMARK: Carga de estudiantes y notificaci√≥n de login
    // === Cargar estudiantes en el select ===
    async function loadStudents() {
      try {
        const response = await fetch("/students");
        const estudiantes = await response.json();

        const select = document.getElementById("selectStudent");
        estudiantes.forEach(est => {
          const opt = document.createElement("option");
          opt.value = est.studentId;     // n√∫mero de registro
          opt.textContent = est.name;    // nombre visible
          select.appendChild(opt);
        });

        // === Funci√≥n para notificar selecci√≥n de estudiante al backend ===
        async function notifyStudentSelection(studentId) {
          try {
            console.log(`ÔøΩ Notificando selecci√≥n de estudiante: ${studentId}`);
            
            // Obtener el nombre del estudiante del dropdown
            const selectStudent = document.getElementById("selectStudent");
            const selectedOption = selectStudent.options[selectStudent.selectedIndex];
            const studentName = selectedOption ? selectedOption.textContent : "Estudiante";
            
            const response = await fetch("/api/student-login", {
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                studentId: studentId,
                timestamp: new Date().toISOString(),
                action: "login"
              })
            });

            if (response.ok) {
              const result = await response.json();
              console.log("‚úÖ Estudiante registrado correctamente:", result);
              
              // Mostrar banner flotante de bienvenida
              showWelcomeBanner(studentName, studentId);
              // Habilitar todos los controles despu√©s del registro exitoso
              enableAllControlsAfterRegistration();
                    // Banner flotante de bienvenida para el estudiante
                    function showWelcomeBanner(studentName, studentId) {
                      // Eliminar cualquier banner previo
                      const oldBanner = document.getElementById('welcomeBanner');
                      if (oldBanner) oldBanner.remove();

                      const banner = document.createElement('div');
                      banner.id = 'welcomeBanner';
                      banner.innerHTML = `
                        <div style="
                          position: fixed;
                          top: 0; left: 0; right: 0;
                          z-index: 9999;
                          background: linear-gradient(90deg, #ff9800 0%, #ffc107 100%);
                          color: #222;
                          font-size: 2.5rem;
                          font-weight: bold;
                          text-align: center;
                          padding: 2.2rem 1rem 1.5rem 1rem;
                          box-shadow: 0 6px 32px rgba(0,0,0,0.18);
                          border-bottom: 4px solid #ff5722;
                          letter-spacing: 1px;
                          transition: top 0.5s;
                        ">
                          üëã ¬°Bienvenido/a, <span style='color:#d84315;'>${studentName}</span>!<br>
                          <span style="font-size:1.5rem; font-weight:normal;">Verifica que tu nombre sea correcto antes de continuar.</span><br>
                          <span style="font-size:1.2rem; color:#333;">ID: <b>${studentId}</b></span>
                          <br><br>
                          <button onclick="this.parentElement.parentElement.remove()" style="
                            font-size: 1.2rem;
                            background: #fff3e0;
                            color: #d84315;
                            border: 2px solid #ff9800;
                            border-radius: 8px;
                            padding: 0.5rem 1.5rem;
                            cursor: pointer;
                            font-weight: bold;
                            margin-top: 0.5rem;
                            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
                          ">Cerrar</button>
                        </div>
                      `;
                      document.body.appendChild(banner);
                    }
            } else {
              // Error del servidor - manejar bloqueos y otros errores
              const errorData = await response.json();
              console.error("‚ùå Error del servidor:", errorData);
              
              if (response.status === 400 && errorData.error) {
                // Bloqueo por IP - mostrar alerta prominente
                alert(`üö´ ACCESO BLOQUEADO\n\n${errorData.error}\n\nContacte al instructor si necesita ayuda.`);
                
                // Revertir la selecci√≥n del dropdown
                document.getElementById("selectStudent").value = "";
                document.getElementById("txtStudentId").value = "";
                
                // Mostrar mensaje de error en la interfaz
                showMessage(`‚ùå BLOQUEADO: ${errorData.error}`, "err");
              } else {
                // Otro tipo de error
                showMessage(`‚ö†Ô∏è Error al registrar estudiante: ${response.status}`, "warn");
              }
            }
          } catch (error) {
            console.error("‚ùå Error de conexi√≥n:", error);
          }
        }

        // üî• Cuando cambie el select ‚Üí copiar el valor al input y notificar al backend
        select.addEventListener("change", async () => {
          const selectedValue = select.value;
          if (selectedValue) {
            // Temporalmente actualizar el campo (se revertir√° si hay error)
            document.getElementById("txtStudentId").value = selectedValue;
            
            // Notificar al backend sobre la selecci√≥n del estudiante
            // Si hay bloqueo, la funci√≥n notifyStudentSelection revertir√° autom√°ticamente
            await notifyStudentSelection(selectedValue);
          } else {
            // Si deseleccion√≥, limpiar el campo
            document.getElementById("txtStudentId").value = "";
          }
        });

      } catch (err) {
        console.error("Error cargando estudiantes:", err);
      }
    }


    // Cargar al inicio
    loadStudents();
  </script>
  
  <script>
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BOOKMARK: Carga de problemas y sincronizaci√≥n autom√°tica de datasets
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //
    // üéØ OPTIMIZACI√ìN PARA REDUCIR CARGA EN EL SERVIDOR (Internet inestable)
    //    + DETECCI√ìN AUTOM√ÅTICA DE CAMBIOS EN ENUNCIADOS
    //
    // ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    // ‚îÇ FLUJO ANTERIOR (‚ùå M√∫ltiples peticiones + sin detecci√≥n de cambios):       ‚îÇ
    // ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    // ‚îÇ  1. Al cargar p√°gina: GET /contest/questions ‚Üí { id, titulo }              ‚îÇ
    // ‚îÇ  2. Usuario selecciona problema A: GET /questions/A/desc ‚Üí { id, text }    ‚îÇ
    // ‚îÇ  3. Usuario selecciona problema B: GET /questions/B/desc ‚Üí { id, text }    ‚îÇ
    // ‚îÇ  4. Usuario vuelve a problema A: GET /questions/A/desc ‚Üí { id, text }      ‚îÇ
    // ‚îÇ                                                                             ‚îÇ
    // ‚îÇ  ‚ö†Ô∏è Problema 1: Cada cambio de problema requiere petici√≥n al servidor      ‚îÇ
    // ‚îÇ  ‚ö†Ô∏è Problema 2: Si el profesor modifica un enunciado, nadie se entera      ‚îÇ
    // ‚îÇ  ‚ö†Ô∏è Problema 3: Con internet inestable, la experiencia es lenta            ‚îÇ
    // ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    //
    // ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    // ‚îÇ FLUJO NUEVO (‚úÖ Cache + Detecci√≥n de cambios + Sync de datasets):          ‚îÇ
    // ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    // ‚îÇ  1. Al cargar p√°gina: GET /contest/questions ‚Üí { id, titulo, text,         ‚îÇ
    // ‚îÇ                                                   lastModified }            ‚îÇ
    // ‚îÇ     ‚îî‚îÄ‚Üí Se guardan TODOS los problemas con descripciones + timestamps      ‚îÇ
    // ‚îÇ                                                                             ‚îÇ
    // ‚îÇ  2. Usuario selecciona problema A:                                          ‚îÇ
    // ‚îÇ     a) Verifica timestamp con servidor (¬øcambi√≥ el enunciado?)             ‚îÇ
    // ‚îÇ     b) Si cambi√≥ ‚Üí actualiza cache + notifica usuario + limpia dataset     ‚îÇ
    // ‚îÇ     c) Carga desde cache actualizado ‚Üí Instant√°neo                          ‚îÇ
    // ‚îÇ     d) Si sandbox activo ‚Üí sincroniza dataset autom√°ticamente               ‚îÇ
    // ‚îÇ                                                                             ‚îÇ
    // ‚îÇ  3. Usuario selecciona problema B:                                          ‚îÇ
    // ‚îÇ     a) Verifica timestamp con servidor                                      ‚îÇ
    // ‚îÇ     b) Carga desde cache (actualizado si cambi√≥)                            ‚îÇ
    // ‚îÇ     c) Sincroniza dataset si sandbox activo                                 ‚îÇ
    // ‚îÇ                                                                             ‚îÇ
    // ‚îÇ  4. Bot√≥n "üîÑ Actualizar Problemas":                                        ‚îÇ
    // ‚îÇ     a) Usuario hace clic (cuando profesor avisa de cambios)                 ‚îÇ
    // ‚îÇ     b) Refresca todos los problemas desde servidor                          ‚îÇ
    // ‚îÇ     c) Actualiza problema seleccionado si hay uno                           ‚îÇ
    // ‚îÇ     d) Sincroniza dataset en sandbox si est√° activo                         ‚îÇ
    // ‚îÇ                                                                             ‚îÇ
    // ‚îÇ  ‚úÖ Beneficios:                                                             ‚îÇ
    // ‚îÇ     ‚Ä¢ Reduce peticiones de (1 + N) a solo 1 petici√≥n inicial               ‚îÇ
    // ‚îÇ     ‚Ä¢ Cambio de problema es instant√°neo (no depende de la red)              ‚îÇ
    // ‚îÇ     ‚Ä¢ Detecci√≥n autom√°tica de cambios en enunciados (por timestamp)         ‚îÇ
    // ‚îÇ     ‚Ä¢ Refresco manual disponible (bot√≥n visible)                            ‚îÇ
    // ‚îÇ     ‚Ä¢ Datasets sincronizados autom√°ticamente si hay cambios                 ‚îÇ
    // ‚îÇ     ‚Ä¢ Funciona offline una vez cargada la p√°gina                            ‚îÇ
    // ‚îÇ     ‚Ä¢ Menor carga en servidor con internet inestable                        ‚îÇ
    // ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    //
    // üîë DETECCI√ìN DE CAMBIOS:
    //    ‚Ä¢ Backend: Lee timestamp de modificaci√≥n del archivo .docx
    //    ‚Ä¢ Frontend: Compara timestamp cache vs servidor al seleccionar problema
    //    ‚Ä¢ Si timestamp servidor > timestamp cache ‚Üí ¬°Enunciado actualizado!
    //    ‚Ä¢ Acci√≥n: Actualiza cache + notifica usuario + limpia/resincroniza dataset
    //
    // üìù Nota: loadInputs() y syncDataset() siguen haciendo sus peticiones normales
    //          Solo se optimiz√≥ la carga de descripciones + detecci√≥n de cambios
    //
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // üöÄ Cache global de problemas (se carga UNA SOLA VEZ al inicio)
    let problemsCache = {};
    
    // üíæ Cache de inputs (datasets) por problema
    // Estructura: { problemId: { inputs: ['input1.txt', 'input2.txt'], files: { 'input1.txt': 'contenido...' } } }
    let inputsCache = {};

    // BOOKMARK: Token global para evitar race conditions al cambiar de problema
    // -------------------------------------------------------------------------
    // TOKEN GLOBAL para evitar race conditions al cambiar de problema
    // Cada vez que el usuario selecciona un nuevo problema, este token se incrementa.
    // Todas las funciones as√≠ncronas que dependen del problema seleccionado reciben
    // el valor del token al iniciar y lo verifican antes de actualizar la UI.
    // Si el token cambi√≥, significa que el usuario ya seleccion√≥ otro problema y
    // la funci√≥n debe terminar sin hacer nada.
    // -------------------------------------------------------------------------
    let problemChangeToken = 0;

    async function loadProblems() {
      try {
        // üì• Obtener TODOS los problemas con descripciones en UNA sola petici√≥n
        const response = await fetch("/contest/questions");
        const problemas = await response.json();

        // üíæ Guardar en cache para uso offline
        problemas.forEach(p => {
          problemsCache[p.id] = {
            id: p.id,
            titulo: p.titulo,
            text: p.text
          };
        });

        console.log(`‚úÖ Cargados ${problemas.length} problemas con descripciones en cache`);

        const select = document.getElementById("selectProblem");
        problemas.forEach(p => {
          const opt = document.createElement("option");
          opt.value = p.id;
          opt.textContent = p.titulo;
          select.appendChild(opt);
        });

        // BOOKMARK: üéØ Cuando selecciona un problema, usar datos del CACHE (sin petici√≥n al servidor)
        select.addEventListener("change", async () => {
            const id = select.value;
            // -----------------------------------------------------------------
            // Cada vez que el usuario cambia de problema, incrementamos el token.
            // Guardamos el valor actual en myToken para todas las funciones as√≠ncronas
            // que dependan de este problema seleccionado.
            // -----------------------------------------------------------------
            const myToken = ++problemChangeToken;
            if (!id) {
              document.getElementById("txtProblemDesc").value = "";
              return;
            }

            try {
              // üî• SIN PETICI√ìN AL SERVIDOR - Usar cache local
              const problemData = problemsCache[id];
              if (!problemData) {
                console.error(`Problema ${id} no encontrado en cache`);
                return;
              }

              // 1) üëá Cargar datos desde cache (INSTANT√ÅNEO, sin red)
              // Antes de actualizar la UI, verificar el token:
              // Si el usuario ya cambi√≥ de problema, no actualizamos la UI.
              if (myToken !== problemChangeToken) return;
              document.getElementById("txtProblemId").value = problemData.id;
              document.getElementById("txtProblemDesc").value = problemData.text;

              // 2) üëá Cargar datasets (inputs) de ese problema, pasando el token
              // El token se pasa a loadInputs y a los eventos internos de datasets.
              await loadInputs(id, myToken);
              if (myToken !== problemChangeToken) return;

              // 3) üîÑ Si el sandbox est√° disponible, sincronizar datasets autom√°ticamente
              if (sandboxAvailable) {
                try {
                  console.log(`üîÑ Sincronizando dataset para problema ${id}...`);
                  const result = await syncDataset(id);
                  if (myToken !== problemChangeToken) return;
                  if (result.uploaded > 0) {
                    console.log(`‚úÖ Sincronizados ${result.uploaded} archivos para problema ${id}`);
                    showToast(`‚úÖ Dataset sincronizado (${result.uploaded} archivos)`, "success");
                  } else {
                    console.log(`‚úÖ Dataset ya estaba completo para problema ${id}`);
                  }
                } catch (err) {
                  if (myToken !== problemChangeToken) return;
                  console.error("Error sincronizando dataset:", err);
                  showToast("‚ö†Ô∏è No se pudo sincronizar el dataset", "warn");
                }
              }
            } catch (err) {
              if (myToken !== problemChangeToken) return;
              console.error("Error cargando problema:", err);
            }
          });
        } catch (err) {
          console.error("Error cargando problemas:", err);
      }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BOOKAMR: FUNCI√ìN: refreshProblems (Actualizar problemas desde el servidor)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    async function refreshProblems() {
      const btn = document.getElementById('btnRefreshProblems');
      const originalText = btn.textContent;
      
      try {
        btn.disabled = true;
        btn.textContent = '‚è≥ Actualizando...';
        
        console.log('üîÑ Refrescando problemas desde el servidor...');
        
        // Obtener problemas actualizados del servidor
        const response = await fetch("/contest/questions");
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const problemas = await response.json();
        
        // Actualizar cache con los datos nuevos
        problemas.forEach(p => {
          problemsCache[p.id] = {
            id: p.id,
            titulo: p.titulo,
            text: p.text
          };
        });
        
        console.log(`‚úÖ Cache actualizado con ${problemas.length} problemas`);
        
        // Si hay un problema seleccionado, recargarlo desde el cache actualizado
        const selectedId = document.getElementById('selectProblem').value;
        if (selectedId) {
          const problemData = problemsCache[selectedId];
          
          if (problemData) {
            console.log(`üîÑ Recargando problema seleccionado: ${selectedId}`);
            
            // Actualizar enunciado en pantalla
            document.getElementById("txtProblemId").value = problemData.id;
            document.getElementById("txtProblemDesc").value = problemData.text;
            
            // Recargar datasets (inputs)
            await loadInputs(selectedId);
            
            // Si sandbox est√° disponible, sincronizar dataset
            if (sandboxAvailable) {
              try {
                console.log(`üîÑ Sincronizando dataset para problema ${selectedId}...`);
                const result = await syncDataset(selectedId);
                if (result.uploaded > 0) {
                  console.log(`‚úÖ Sincronizados ${result.uploaded} archivos`);
                  showToast(`‚úÖ Dataset actualizado (${result.uploaded} archivos)`, "success");
                }
              } catch (err) {
                console.error("Error sincronizando dataset:", err);
                showToast("‚ö†Ô∏è No se pudo sincronizar el dataset", "warn");
              }
            }
            
            showToast('‚úÖ Enunciado y datos actualizados', 'success');
          }
        } else {
          showToast('‚úÖ Problemas actualizados', 'success');
        }
        
      } catch (err) {
        console.error('‚ùå Error refrescando problemas:', err);
        
        let errorMsg = '‚ùå Error al actualizar problemas';
        if (err.message.includes('Failed to fetch')) {
          errorMsg = '‚ö†Ô∏è No se puede conectar con el servidor';
        } else if (err.message.includes('530')) {
          errorMsg = '‚ö†Ô∏è El servidor no est√° disponible (530)';
        }
        
        showToast(errorMsg, 'error');
        alert(`${errorMsg}\n\nDetalle: ${err.message}`);
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
      }
    }

    // Cargar al inicio
    loadProblems();
  </script>

  <script>
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BOOKMARK: Carga de inputs (datasets) para el problema seleccionado
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    async function loadInputs(problemId, token) {
      const select = document.getElementById("selectInput");
      select.innerHTML = "<option value=''>-- Seleccione un dataset --</option>";
      // -----------------------------------------------------------------
      // Usar el token actual si no se pasa (compatibilidad)
      // As√≠, si el usuario cambia de problema mientras se cargan los datasets,
      // cualquier respuesta atrasada ser√° ignorada.
      // -----------------------------------------------------------------
      const myToken = typeof token === 'undefined' ? problemChangeToken : token;

      try {
        const response = await fetch(`/problems/${problemId}/inputs`);
        
        if (!response.ok) {
          // Detectar si es un error de Cloudflare o del servidor
          const contentType = response.headers.get('content-type');
          
          if (contentType && contentType.includes('text/html')) {
            // Es HTML (p√°gina de error de Cloudflare), no JSON
            console.warn(`‚ö†Ô∏è Servidor no disponible al cargar inputs del problema ${problemId} (HTML recibido)`);
            select.innerHTML = "<option value=''>‚ö†Ô∏è Servidor no disponible</option>";
            return;
          }
          
          // Otro tipo de error
          const errorText = await response.text();
          console.error(`‚ùå Error cargando inputs (${response.status}):`, errorText);
          select.innerHTML = "<option value=''>‚ùå Error al cargar datasets</option>";
          return;
        }
        
        // Intentar parsear JSON
        let archivos;
        try {
          archivos = await response.json();
        } catch (parseErr) {
          console.error("‚ùå Respuesta no es JSON v√°lido:", parseErr);
          select.innerHTML = "<option value=''>‚ö†Ô∏è Respuesta inv√°lida del servidor</option>";
          return;
        }
        
        // Cargar archivos en el select
        archivos.forEach(a => {
          const opt = document.createElement("option");
          opt.value = a;
          opt.textContent = a;
          select.appendChild(opt);
        });

        // evento: cuando selecciona un dataset
        select.addEventListener("change", async () => {
          const archivo = select.value;
          if (!archivo) return;

          // -----------------------------------------------------------------
          // Verificar token antes de cargar el dataset:
          // Si el usuario ya cambi√≥ de problema, no se actualiza el input.
          // -----------------------------------------------------------------
          if (myToken !== problemChangeToken) return;

          try {
            const r = await fetch(`/problems/${problemId}/input/${archivo}`);
            if (myToken !== problemChangeToken) return;
            if (!r.ok) {
              console.warn(`‚ö†Ô∏è No se pudo cargar el archivo ${archivo}`);
              alert(`‚ö†Ô∏è No se pudo cargar el archivo ${archivo}\n\nEl servidor puede estar temporalmente no disponible. Si el sandbox local est√° habilitado, se intentar√° cargar de √©l.`);
              return;
            }
            const contenido = await r.text();
            if (myToken !== problemChangeToken) return;
            document.getElementById("stdin").value = contenido;
          } catch (err) {
            if (myToken !== problemChangeToken) return;
            console.error("Error cargando contenido del dataset:", err);
            alert(`‚ö†Ô∏è Error al cargar el dataset\n\n${err.message}`);
          }
        });

      } catch (err) {
        console.error("‚ùå Error en loadInputs:", err);
        
        // Verificar si es error de red
        if (err.message.includes('Failed to fetch') || err.name === 'TypeError') {
          console.warn("‚ö†Ô∏è No se puede conectar con el servidor");
          select.innerHTML = "<option value=''>‚ö†Ô∏è Sin conexi√≥n al servidor</option>";
        } else {
          select.innerHTML = "<option value=''>‚ùå Error desconocido</option>";
        }
      }
    }
    </script>
    
    <script>
      /*
      Al abrir index.html: se descarga /utils/tree (solo la primera vez).
      1. - El alumno ve un explorador de carpetas.
      2. - Puede expandir/cerrar carpetas.
      3. - Al hacer clic en un archivo ‚Üí se abre el c√≥digo en el textarea, listo para copiar/pegar.
  `   4. - Todo queda cacheado en IndexedDB ‚Üí si se abre de nuevo, no hace otra request al servidor.
      */
      // --- IndexedDB Helper ---
      const DB_NAME = "UtilsDB";
      const DB_STORE = "files";
      function openDB() {
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(DB_NAME, 1);
          req.onupgradeneeded = () => req.result.createObjectStore(DB_STORE);
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      }
      async function cachePut(key, value) {
        const db = await openDB();
        const tx = db.transaction(DB_STORE, "readwrite");
        tx.objectStore(DB_STORE).put(value, key);
      }
      async function cacheGet(key) {
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(DB_STORE, "readonly");
          const req = tx.objectStore(DB_STORE).get(key);
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      }

      // --- Render tree ---
      function renderTree(node, container, isRoot = false) {
        if (node.type === "dir") {
          const div = document.createElement("div");
          div.className = "folder";
          div.textContent = "üìÇ " + node.name;
          container.appendChild(div);

          const children = document.createElement("div");
          children.style.marginLeft = "15px";
          // üëá Si es el directorio ra√≠z ‚Üí expandido, si no ‚Üí oculto
          children.style.display = isRoot ? "block" : "none";
          container.appendChild(children);

          div.onclick = () => {
            children.style.display = children.style.display === "none" ? "block" : "none";
          };

          node.children.forEach(child => renderTree(child, children));
        } else if (node.type === "file") {
          const div = document.createElement("div");
          div.className = "file";
          div.textContent = "üìÑ " + node.name;
          div.onclick = () => loadFile(node.path);
          container.appendChild(div);
        }
      }


      // --- Load file (with cache) ---
      async function loadFile(path) {
        let content = await cacheGet(path);
        if (!content) {
          const res = await fetch(`/utils/file/${path}`);
          if (!res.ok) {
            alert("No se pudo cargar " + path);
            return;
          }
          content = await res.text();
          await cachePut(path, content);
        }
        document.getElementById("utils-content").value = content;
      }

      // --- Init ---
      async function initUtils() {
        try {
          let tree = await cacheGet("tree");
          if (!tree) {
            const res = await fetch("/utils/tree");
            tree = await res.json();
            await cachePut("tree", tree);
          }
          
          const container = document.getElementById("utils-tree");
          container.innerHTML = "";
          renderTree(tree, container, true); // üëà el ra√≠z expandido

        } catch (err) {
          console.error("Error cargando utilitarios:", err);
        }
      }
      initUtils();
      </script>

      <script>
        /*
        - Al copiar c√≥digo ‚Üí aparece un toast verde ‚úÖ confirmando.
        - Si no hay contenido ‚Üí un toast naranja ‚ö†Ô∏è.
        - Si ocurre un error ‚Üí un toast rojo ‚ùå.
        - Todos se desvanecen solos despu√©s de 3 segundos.
        */
        // Mostrar toast
        function showToast(message, type = "info") {
          const container = document.getElementById("toast-container");
          const toast = document.createElement("div");
          toast.className = "toast";
          toast.textContent = message;

          // Color seg√∫n tipo
          if (type === "success") toast.style.background = "#4caf50";
          if (type === "error") toast.style.background = "#f44336";
          if (type === "warn") toast.style.background = "#ff9800";

          container.appendChild(toast);

          // Mostrar
          setTimeout(() => toast.classList.add("show"), 50);

          // Ocultar y eliminar
          setTimeout(() => {
            toast.classList.remove("show");
            setTimeout(() => toast.remove(), 500);
          }, 3000);
        }

        // Copiar al portapapeles con toast
        document.getElementById("copy-btn").addEventListener("click", async () => {
          const textarea = document.getElementById("utils-content");
          if (!textarea.value.trim()) {
            showToast("‚ö†Ô∏è No hay contenido para copiar.", "warn");
            return;
          }
          try {
            await navigator.clipboard.writeText(textarea.value);
            showToast("‚úÖ C√≥digo copiado al portapapeles.", "success");
          } catch (err) {
            console.error("Error al copiar:", err);
            showToast("‚ùå No se pudo copiar el contenido.", "error");
          }
        });
        </script>

      <div id="toast-container"></div>
      
      
      <script>
        // --- Modo oscuro / claro ---
        const themeToggle = document.getElementById("theme-toggle");

        // Leer tema guardado
        const savedTheme = localStorage.getItem("theme") || "light";
        applyTheme(savedTheme);

        themeToggle.addEventListener("click", () => {
          const current = document.body.classList.contains("dark-mode") ? "dark" : "light";
          const next = current === "dark" ? "light" : "dark";
          applyTheme(next);
          localStorage.setItem("theme", next);
        });

        function applyTheme(mode) {
          if (mode === "dark") {
            document.body.classList.add("dark-mode");
            themeToggle.textContent = "‚òÄÔ∏è";
            if (monacoEditor) monaco.editor.setTheme("vs-dark");
            document.querySelectorAll(".CodeMirror").forEach(cm => cm.classList.add("cm-s-monokai"));
          } else {
            document.body.classList.remove("dark-mode");
            themeToggle.textContent = "üåô";
            if (monacoEditor) monaco.editor.setTheme("vs-light");
            document.querySelectorAll(".CodeMirror").forEach(cm => cm.classList.remove("cm-s-monokai"));
          }
        }
      </script>

</body>
</html>

