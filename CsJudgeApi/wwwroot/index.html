<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Juez Online</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .tab { display: inline-block; padding: 10px 20px; margin-right: 5px; border: 1px solid #ccc; border-bottom: none; cursor: pointer; background: #eee; }
    .tab.active { background: #fff; font-weight: bold; }
    .editor-container { border: 1px solid #ccc; padding: 10px; }
    .CodeMirror { border: 1px solid #ccc; height: 300px; font-size: 14px; }
    #monaco-container { width: 100%; height: 300px; border: 1px solid #ccc; display: none; }
    .result { margin-top: 20px; padding: 10px; border-radius: 5px; white-space: pre-wrap; }
    .ok { background: #e0ffe0; border: 1px solid #0c0; }
    .warn { background: #fff5cc; border: 1px solid #cc0; }
    .err { background: #ffe0e0; border: 1px solid #c00; }
    
    
    #stdin {
      resize: both;         /* permite agrandar con el mouse */
      min-height: 150px;    /* alto mÃ­nimo */
      min-width: 300px;     /* ancho mÃ­nimo */
      width: 100%;          /* por defecto ocupa todo el ancho */
    }
    
    
    #utils-panel {
      float: left;
      width: 25%;
      height: 400px;
      overflow-y: auto;
      border: 1px solid #ccc;
      padding: 5px;
      font-family: monospace;
      background: #f9f9f9;
    }

    #utils-viewer {
      margin-left: 26%;
      height: 400px;
    }

    #utils-content {
      width: 100%;
      height: 100%;
      font-family: monospace;
      white-space: pre;
    }
    .folder { cursor: pointer; font-weight: bold; }
    .file { cursor: pointer; margin-left: 15px; }

    #copy-btn {
      margin-bottom: 5px;
      padding: 5px 10px;
      font-size: 14px;
      cursor: pointer;
      background: #4caf50;
      color: white;
      border: none;
      border-radius: 5px;
    }
    #copy-btn:hover {
      background: #45a049;
    }

    /* Toast container */
    #toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
    }

    /* Toast message */
    .toast {
      background: #333;
      color: white;
      padding: 10px 20px;
      margin-top: 5px;
      border-radius: 5px;
      font-size: 14px;
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.5s, transform 0.5s;
    }

    /* Visible state */
    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }
    
    /* Cambia el color de fondo de las textarea de solo lectura */ 
    textarea[readonly] {
      background-color: #f4f4f4; /* gris claro */
      color: #333;              /* texto mÃ¡s oscuro */
      border: 1px solid #ccc;
    }

    /* Cambia el color de fondo de los text de solo lectura */ 
    input[readonly] {
       background-color: #fff8dc; /* palido, tipo bloc de notas */
    }

    /* Cambio suave entre tema */
    body, textarea, input, select {
      transition: background-color 0.3s, color 0.3s;
    }

  </style>
  
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin:0; padding:0; }

    /* BotÃ³n flotante */
    .floating-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: #0056b3;
      color: white;
      padding: 15px 20px;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      font-size: 16px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      z-index: 10000;
    }
    .floating-btn:hover { background-color: #004494; }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      z-index: 9999;
      left: 0; top: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.6);
    }
    .modal-content {
      background: #fff;
      margin: 5% auto;
      padding: 20px;
      border-radius: 10px;
      width: 80%;
      max-height: 80%;
      overflow-y: auto;
    }
    .close {
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    pre {
      background: #eee;
      padding: 10px;
      border-radius: 5px;
      position: relative;
      overflow-x: auto;
    }
    .copy-btn {
      position: absolute;
      top: 5px; right: 5px;
      background: #444;
      color: white;
      border: none;
      padding: 5px 10px;
      font-size: 12px;
      cursor: pointer;
      border-radius: 3px;
    }
    .copy-btn:hover { background: #222; }
    
    /* === Tema oscuro === */
    body.dark-mode {
      background-color: #1e1e1e;
      color: #ddd;
    }

    body.dark-mode textarea,
    body.dark-mode input,
    body.dark-mode select {
      background-color: #2b2b2b;
      color: #eee;
      border-color: #555;
    }

    body.dark-mode .editor-container,
    body.dark-mode #utils-panel,
    body.dark-mode #utils-viewer,
    body.dark-mode .result {
      background-color: #252526;
      border-color: #555;
      color: #ddd;
    }

    body.dark-mode #copy-btn {
      background: #006400;
    }

    body.dark-mode .tab {
      background: #333;
      color: #ccc;
      border-color: #555;
    }

    body.dark-mode .tab.active {
      background: #1e1e1e;
      color: #fff;
      border-bottom: 1px solid #1e1e1e;
    }

    body.dark-mode #toast-container .toast {
      background: #444;
    }

  </style>
  
  <!-- CodeMirror -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/clike/clike.min.js"></script>
  
  <!--
  El archivo monokai.min.css define los colores de sintaxis, fondo, nÃºmeros de lÃ­nea, etc. para CodeMirror cuando se usa el tema "monokai".
  Por ejemplo:
  - Fondo negro (#272822)
  - Texto claro
  - Keywords en azul/verde
  - Literales en naranja
  -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/monokai.min.css">

  <!-- Monaco -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>
  <script>
    /* Esperar a que el loader de Monaco estÃ© disponible; ya que, el require de Monaco aÃºn no estÃ¡ definido en ese punto
   cuando se carga el script (porque loader.min.js se ejecuta de forma asÃ­ncrona).*/ 
    window.addEventListener("load", () => {
      require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' } });
      require(['vs/editor/editor.main'], function () {
        console.log("âœ… Monaco base cargado");
      });
    });
  </script>

  </head>
  
  
  <body>

  <!-- BotÃ³n flotante -->
  <button class="floating-btn" onclick="openModal()">ğŸ“˜ Reglas</button>

  <!-- Modal -->
  <div id="reglasModal" class="modal">
    <div class="modal-content">
      <span class="close" onclick="closeModal()">&times;</span>
      <div id="markdown-content"></div>
    </div>
  </div>

  <script>
  function openModal() {
    document.getElementById("reglasModal").style.display = "block";
    fetch("Juez_Virtual_Instructivo.markdown")
      .then(res => res.text())
      .then(text => {
        const html = marked.parse(text);
        document.getElementById("markdown-content").innerHTML = html;
        addCopyButtons();
      });
  }

  function closeModal() {
    document.getElementById("reglasModal").style.display = "none";
  }

  function addCopyButtons() {
    document.querySelectorAll("pre code").forEach(block => {
      // Evitar duplicados
      if (block.parentNode.querySelector(".copy-btn")) return;
      const button = document.createElement("button");
      button.innerText = "ğŸ“‹ Copiar";
      button.className = "copy-btn";
      button.onclick = () => {
        navigator.clipboard.writeText(block.innerText);
        button.innerText = "âœ… Copiado!";
        setTimeout(() => button.innerText = "ğŸ“‹ Copiar", 2000);
      };
      block.parentNode.style.position = "relative";
      block.parentNode.appendChild(button);
    });
  }
  </script>

  
  <h1>Juez Online</h1>
  <button id="theme-toggle" style="
              position: fixed;
              bottom: 90px;
              right: 20px;
              background-color: #333;
              color: white;
              padding: 10px 15px;
              border: none;
              border-radius: 50px;
              cursor: pointer;
              font-size: 16px;
              box-shadow: 0 4px 6px rgba(0,0,0,0.3);
              z-index: 10000;">ğŸŒ™</button>

  <div>
    <div id="tab-cm" class="tab active" onclick="switchEditor('cm')">Editor rÃ¡pido (CodeMirror)</div>
    <div id="tab-monaco" class="tab" onclick="switchEditor('monaco')">Editor avanzado (Monaco)</div>
  </div>

  <p id="monaco-warning" style="color:red; display:none;">
    âš ï¸ El editor Monaco es mÃ¡s pesado, puede tardar unos segundos en cargar.
  </p>

  <label id="lblProblemId">Id del Problema:</label>
  <input type="text" id="txtProblemId" style="width: 40px;" required minlength="1" readonly>
  <span>
    <label for="selectProblem">Seleccione el problema:</label>
    <select id="selectProblem">
      <option value="">-- Seleccione --</option>
    </select>
  </span>
  <span>
    <label for="selectInput">Seleccione dataset:</label>
    <select id="selectInput">
      <option value="">-- Seleccione un dataset --</option>
    </select>
  </span>
  <br><br>

  <label id="lblStudentId">Id del Estudiante:</label>
  <input type="text" id="txtStudentId" style="width: 100px;" required minlength="1" readonly>
  <span>
    <label for="selectStudent">O selecciona tu nombre:</label>
    <select id="selectStudent">
      <option value="">-- Selecciona tu nombre --</option>
    </select>
  </span>
  <br><br>
  
  <label for="txtProblemDesc">DescripciÃ³n del problema:</label><br>
  <textarea id="txtProblemDesc" rows="30" cols="200" readonly></textarea>
  
  <div id="utils-panel">
    <h3>ğŸ“‚ <strong><i>UTILITARIOS PARA REFERENCIA DE SINTAXIS E INSTRUCCIONES EN C#</i></strong></h3>
    <div id="utils-tree"></div>
  </div>

  <div id="utils-viewer">
    <h3>ğŸ“„ Contenido del archivo en <strong>Utilitarios</strong></h3>
    <button id="copy-btn">ğŸ“‹ Copiar al portapapeles</button>
    <textarea id="utils-content" readonly></textarea>
  </div>

    <label for="selectLanguage">Lenguaje:</label>
  <select id="selectLanguage">
    <option value="csharp">C#</option>
    <option value="cpp">C++</option>
    <!-- futuro: <option value="python">Python</option> -->
  </select>
  <br><br>

  <div class="editor-container">
    <textarea id="code-cm"></textarea>
  <div id="monaco-container"></div>
  </div>



  <script>
    // BOOKMARK: ConfiguraciÃ³n de lenguajes (C#, C++)
    // âš¡ Mapear lenguaje elegido â†’ configuraciÃ³n de editores + Judge0
    const LANG_CONFIG = {
      csharp: {
        codemirror: "text/x-csharp",
        monaco: "csharp",
        judge0: 51,
        filename: "solucion.cs",
        template: `using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

class Program
{
    static void Main()
    {
        string line;
        
        // Leer hasta que no haya mÃ¡s lÃ­neas (hasta el final del stream)
        while ((line = Console.ReadLine()) != null)
        {
            Console.WriteLine($"valor enviado={line}");
        }
        Console.WriteLine("Hola C#!");
    }
}`
      },
      cpp: {
        codemirror: "text/x-c++src",
        monaco: "cpp",
        judge0: 54,
        filename: "solucion.cpp",
        template: `  #include <bits/stdc++.h>
  using namespace std;
  int main() {
      string line;
      while (getline(cin, line)) {
          cout << "valor enviado=" << line << endl;
      }
      cout << "Hola C++!" << endl;
      return 0;
  }`
      }
    };

    let monacoEditor = null;


    function getSelectedLang() {
      const val = document.getElementById("selectLanguage").value;
      return LANG_CONFIG[val] || LANG_CONFIG.csharp;
    }

    // === Inicializar CodeMirror con cÃ³digo por defecto ===
    const defaultConfig = getSelectedLang();
    const cmEditor = CodeMirror.fromTextArea(document.getElementById("code-cm"), {
      lineNumbers: true,
      mode: defaultConfig.codemirror,
      theme: "default"
    });
    
    // Establecer el contenido inicial
    cmEditor.setValue(defaultConfig.template);
    
    // Mostrar el cÃ³digo en la consola (para depuraciÃ³n)
    function showCodeParamInConsole(code) {
      console.log("=== CÃ“DIGO ACTUAL ===");
      console.log(code);
      console.log("=== FIN DEL CÃ“DIGO ===");
    }

    // Obtener el cÃ³digo actual (de CodeMirror o Monaco)
    function showCodeInConsole() {
        const code = getCurrentCode();
        showCodeParamInConsole(code);
    }

    // BOOKMARK: Cambio entre editores CodeMirror y MÃ³naco
    // === FunciÃ³n switchEditor (debe estar disponible globalmente) ===
    function switchEditor(type) {
      // Depurar, en la consola, el cÃ³digo actual
      console.log("=== CÃ“DIGO ACTUAL ANTES DE CAMBIAR DE EDITOR DE CÃ“DIGO ===");
      showCodeInConsole();

      document.getElementById("tab-cm").classList.remove("active");
      document.getElementById("tab-monaco").classList.remove("active");
      
      if (type === "cm") {
        document.getElementById("tab-cm").classList.add("active");
        document.getElementById("monaco-container").style.display = "none";
        document.getElementById("monaco-warning").style.display = "none";
        cmEditor.getWrapperElement().style.display = "block";
      } else {
        document.getElementById("tab-monaco").classList.add("active");
        document.getElementById("monaco-container").style.display = "block";
        document.getElementById("monaco-warning").style.display = "block";
        cmEditor.getWrapperElement().style.display = "none";
        
        // Asegurarse de que Monaco se redibuje correctamente
        if (monacoEditor) {
          setTimeout(() => monacoEditor.layout(), 50);
        }
      }
    }

    // === InicializaciÃ³n de Monaco ===
    require.config({ 
      paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' } 
    });

    require(["vs/editor/editor.main"], function () {
      monacoEditor = monaco.editor.create(document.getElementById('monaco-container'), {
        value: `using System;
using System.Linq; // Para utilizar poder Linq
using System.Collections.Generic; // Para poder trabajar con listas, diccionarios, etc.

// Ejemplo para ser probado en Monaco (con entrada desde teclado).
class Program
{
    static void Main()
    {
        string val;
        while (!string.IsNullOrEmpty(val = Console.ReadLine()))
        {
            Console.WriteLine($"Valor enviado={val}");
        }
        Console.WriteLine("Hola Monaco!");
    }
}`,
        language: "csharp",
        theme: "vs-light",
        automaticLayout: true
      });
      console.log("âœ… Monaco cargado correctamente");
    });

    // === Cambio de lenguaje (compatible con CodeMirror y Monaco) ===
    document.getElementById("selectLanguage").addEventListener("change", () => {
      const cfg = getSelectedLang();

      // Depurar, en la consola, el cÃ³digo actual antes de cambiar
      console.log("=== CÃ“DIGO ACTUAL ANTES DE CAMBIAR DE LENGUAJE ===");
      showCodeInConsole();

      // CodeMirror
      cmEditor.setOption("mode", cfg.codemirror);
      cmEditor.setValue(cfg.template);

      // Monaco (si ya estÃ¡ creado)
      if (monacoEditor) {
        monaco.editor.setModelLanguage(monacoEditor.getModel(), cfg.monaco);
        monacoEditor.setValue(cfg.template);
        monacoEditor.layout();
      }
    });

    // === Inicializar CodeMirror con plantilla inicial ===
    window.addEventListener("load", () => {
      const cfg = getSelectedLang();
      cmEditor.setOption("mode", cfg.codemirror);
      cmEditor.setValue(cfg.template);
    });


    
  </script>

  <script>
    // Hacer el envio
    const JUDGE0_URL = "https://ce.judge0.com/submissions?base64_encoded=true&wait=true";

    function getCurrentCode() {
      if (document.getElementById("tab-cm").classList.contains("active")) {
        return cmEditor.getValue();
      } else {
        return monacoEditor ? monacoEditor.getValue() : "";
      }
    }

    // BOOKMARK: EjecuciÃ³n en Judge0 (juez de prueba)
    async function runJudge0() {
      const code = getCurrentCode();
      
      let stdin = document.getElementById('stdin').value;

      if (!code.trim()) {
        showMessage("âš ï¸ El cÃ³digo estÃ¡ vacÃ­o, no se puede enviar a Judge0.", "err");
        return;
      }

      console.log("=== CÃ“DIGO ACTUAL ANTES DE ENVIAR A JUDGE0 ===");
      showCodeParamInConsole(code);

      showMessage("â³ Ejecutando en Judge0...", "warn");

      try {
        const response = await fetch(JUDGE0_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            // ğŸ‘‡ importante: enviar como Base64
            source_code: btoa(unescape(encodeURIComponent(code))),
            language_id: getSelectedLang().judge0,
            stdin: btoa(unescape(encodeURIComponent(stdin)))
          })
        });

        if (!response.ok) {
          const errText = await response.text();
          showMessage("âŒ Judge0 devolviÃ³ " + response.status + ":\n" + errText, "err");
          return;
        }

        const result = await response.json();
        
        function decodeBase64(b64) {
          try {
            return decodeURIComponent(escape(atob(b64)));
          } catch (e) {
            return b64; // si no es vÃ¡lido, lo dejo tal cual
          }
        }

        const stdout = result.stdout ? decodeBase64(result.stdout) : "";
        const stderr = result.stderr ? decodeBase64(result.stderr) : "";
        const compile_output = result.compile_output ?    decodeBase64(result.compile_output) : "";

        if (stderr || compile_output) {
          showMessage("âŒ Error:\n" + (stderr || compile_output), "err");
        } else {
          showMessage("âœ… Salida:\n" + stdout +
                      "\n\nEstado: " + (result.status?.description || "??"), "ok");
        }
      } catch (err) {
        showMessage("âš ï¸ Error al conectar con Judge0:\n" + err, "err");
      }
    }

    // BOOKMARK: EjecuciÃ³n en servidor oficial (calificable)
    async function runOfficial() {
      const problemId = document.getElementById('txtProblemId').value;
      const studentId = document.getElementById('txtStudentId').value;
      const code = getCurrentCode();
      const stdin = document.getElementById('stdin').value;

      if (!problemId) { alert("Por favor, introduce el identificador de la pregunta."); return; }
      if (!studentId) { alert("Por favor, introduce el identificador del estudiante."); return; }

      if (!code.trim()) {
        showMessage("âš ï¸ El cÃ³digo estÃ¡ vacÃ­o, no se puede enviar a Judge0.", "err");
        return;
      }

      console.log("=== CÃ“DIGO ACTUAL ANTES DE ENVIAR AL SERVIDOR OFICIAL ===");
      showCodeParamInConsole(code);

      showMessage("â³ Enviando a servidor oficial...", "warn");

      try {
        const formData = new FormData();
        const blob = new Blob([code], { type: "text/plain" });
        formData.append("code", blob, getSelectedLang().filename);
        formData.append("language", document.getElementById("selectLanguage").value);
        formData.append("stdin", stdin);
        formData.append("problemId", problemId);
        formData.append("studentId", studentId);

        const response = await fetch("/compile-run", {
          method: "POST",
          body: formData
        });

        if (!response.ok) {
          const errorText = await response.text();
          showMessage("âŒ Error del servidor:\n" + errorText, "err");
          return;
        }

        const result = await response.json();
        if (result.build !== "build:ok") {
          showMessage("âŒ Errores de compilaciÃ³n:\n" + (result.buildLog || "Sin detalles"), "err");
          return;
        }
        if (result.run !== "run:ok") {
          showMessage("âŒ Error en ejecuciÃ³n:\n" +
            (result.runLog || "Sin detalles") +
            (result.stderrRaw ? "\nSTDERR:\n" + result.stderrRaw : "") +
            "\nğŸ“ Summary: " + (result.summary),
            "err"
          );
          return;
        }

        showMessage("âœ… EjecuciÃ³n exitosa\n\nSalida:\n" + (result.runLog || "") +
          "\n\nâ± Tiempo: " + (result.time || "-") +
          "\nğŸ’¾ Memoria: " + (result.memKb || "-") + " KB" +
          "\nğŸ“ Summary: " + (result.summary),
          "ok"
        );

      } catch (err) {
        showMessage("âš ï¸ No se pudo conectar al servidor oficial:\n" + err, "err");
      }
    }

    function showMessage(msg, type) {
      const out = document.getElementById("output");
      out.className = "result " + type;
      out.textContent = msg;
    }
  </script>

  <br>
  <label for="stdin">Entrada (stdin):</label><br>
  <textarea id="stdin" rows="15" cols="80" style="width: 100%;"></textarea>

  <button id="btnJudge0" type="button" onclick="runJudge0()">Ejecutar (En Juez de<br>Prueba)</button>
  <button id="btnOfficial" type="button" onclick="runOfficial()">Enviar (En Juez Oficial,<br> <strong>es calificable para el contest</strong>)</button>

  <div style="margin-top: 10px;">
    <button id="btnSandbox" onclick="runLocalCode()" disabled title="Verificando sandbox...">ğŸ§ª Probar en Sandbox</button>
    <button id="btnValidation" onclick="runOfflineValidation()" disabled title="Verificando sandbox...">ğŸ“‚ Validar con DataSet local</button>
    <button id="btnDownloadSandbox" onclick="downloadSandbox()" style="background-color: #ff9800;">ğŸ“¥ Descargar Sandbox</button>
  </div>

  <pre id="validationLog"></pre>
  <div id="output" class="result"></div>

  
  <script>
    // BOOKMARK: ConfiguraciÃ³n de URLs del servidor y sandbox
    // Constantes de configuraciÃ³n
    // Esta URL serÃ¡ reemplazada por el script start_judge.sh con la URL de ngrok
    const SERVER_BASE_URL = "https://8cd82cf5fd87.ngrok-free.app";
    const SANDBOX_BASE = "http://localhost:1100";
    const SANDBOX_URL = SANDBOX_BASE; // Alias para compatibilidad
    const SANDBOX_DOWNLOAD_URL = `${SERVER_BASE_URL}/assets/DotNetInteractiveServer.zip`;

    // Estado del sandbox
    let sandboxAvailable = false;
    let checkInterval = null;

    // BOOKMARK: InicializaciÃ³n del sandbox al cargar pÃ¡gina
    // Verificar si el sandbox estÃ¡ disponible al cargar la pÃ¡gina
    window.addEventListener('DOMContentLoaded', async () => {
      console.log('ğŸš€ PÃ¡gina cargada, iniciando verificaciÃ³n del sandbox...');
      await checkAndPromptSandbox();
      console.log('âœ… VerificaciÃ³n inicial del sandbox completada');
    });

    // Verificar si el sandbox responde (sin UI)
    async function pingSandbox() {
      try {
        console.log(`ğŸ“¡ Intentando ping a: ${SANDBOX_BASE}/ping`);
        const res = await fetch(`${SANDBOX_BASE}/ping`, {
          method: 'GET',
          signal: AbortSignal.timeout(2000)
        });
        
        console.log(`ğŸ“¡ Respuesta ping: status=${res.status}, ok=${res.ok}`);
        if (!res.ok) return false;
        
        // Verificar que responda con el mensaje esperado
        const text = await res.text();
        console.log(`ğŸ“¡ Texto respuesta ping: "${text}"`);
        const isValid = text.includes('Sandbox activo') || text.includes('âœ…');
        console.log(`ğŸ“¡ Ping vÃ¡lido: ${isValid}`);
        return isValid;
      } catch (err) {
        console.log(`âŒ Error en ping: ${err.message}`);
        return false;
      }
    }

    // Habilitar botones del sandbox (y tambiÃ©n Judge0 y Oficial)
    function enableSandboxButtons() {
      const btnSandbox = document.getElementById('btnSandbox');
      const btnValidation = document.getElementById('btnValidation');
      const btnJudge0 = document.getElementById('btnJudge0');
      const btnOfficial = document.getElementById('btnOfficial');
      
      sandboxAvailable = true;
      btnSandbox.disabled = false;
      btnValidation.disabled = false;
      btnJudge0.disabled = false;
      btnOfficial.disabled = false;
      btnSandbox.title = 'Sandbox local disponible';
      btnValidation.title = 'Sandbox local disponible';
      btnJudge0.title = '';
      btnOfficial.title = '';
      btnSandbox.textContent = 'ğŸ§ª Probar en Sandbox';
      btnValidation.textContent = 'ğŸ“‚ Validar con DataSet local';
      
      console.log('âœ… Sandbox local disponible - Todos los botones habilitados');
      
      // Detener el chequeo periÃ³dico
      if (checkInterval) {
        clearInterval(checkInterval);
        checkInterval = null;
      }
    }

    // Deshabilitar botones del sandbox (y tambiÃ©n Judge0 y Oficial durante validaciÃ³n)
    function disableSandboxButtons(message) {
      const btnSandbox = document.getElementById('btnSandbox');
      const btnValidation = document.getElementById('btnValidation');
      const btnJudge0 = document.getElementById('btnJudge0');
      const btnOfficial = document.getElementById('btnOfficial');
      
      sandboxAvailable = false;
      btnSandbox.disabled = true;
      btnValidation.disabled = true;
      btnJudge0.disabled = true;
      btnOfficial.disabled = true;
      btnSandbox.title = message;
      btnValidation.title = message;
      btnJudge0.title = message;
      btnOfficial.title = message;
      btnSandbox.textContent = message;
      btnValidation.textContent = message;
      
      console.log(`ğŸ”’ Todos los botones deshabilitados: ${message}`);
    }

    // BOOKMARK: Monitoreo periÃ³dico del sandbox cada 5 segundos
    // Iniciar verificaciÃ³n periÃ³dica del sandbox
    function startSandboxMonitoring() {
      if (checkInterval) return; // Ya estÃ¡ monitoreando
      
      console.log('ğŸ”„ Iniciando monitoreo del sandbox (cada 5 segundos)...');
      
      checkInterval = setInterval(async () => {
        const isAlive = await pingSandbox();
        if (isAlive) {
          console.log('âœ… Sandbox detectado corriendo!');
          enableSandboxButtons();
        }
      }, 5000); // Verificar cada 5 segundos
    }

    // BOOKMARK: VerificaciÃ³n inicial y descarga del sandbox
    // Verificar sandbox y ofrecer descarga si no estÃ¡
    async function checkAndPromptSandbox() {
      console.log('ğŸ” Iniciando verificaciÃ³n del sandbox...');
      const btnSandbox = document.getElementById('btnSandbox');
      const btnValidation = document.getElementById('btnValidation');
      
      // SIEMPRE verificar primero si el sandbox estÃ¡ corriendo (ping)
      console.log('ğŸ“¡ Haciendo ping al sandbox...');
      const isAlive = await pingSandbox();
      
      if (isAlive) {
        console.log('âœ… Sandbox detectado activo!');
        enableSandboxButtons();
        return;
      }

      console.log('âŒ Sandbox NO responde al ping');

      // Si no estÃ¡ activo, verificar si ya se descargÃ³ previamente
      const alreadyDownloaded = localStorage.getItem('sandboxDownloaded');
      console.log('ğŸ’¾ LocalStorage sandboxDownloaded:', alreadyDownloaded);
      
      if (alreadyDownloaded) {
        // Ya se descargÃ³, solo esperar que se ejecute
        console.log('â³ Sandbox ya fue descargado, esperando que se ejecute...');
        btnSandbox.title = 'Esperando que ejecutes el sandbox local...';
        btnValidation.title = 'Esperando que ejecutes el sandbox local...';
        startSandboxMonitoring(); // Iniciar monitoreo automÃ¡tico
        return;
      }

      // Sandbox no disponible y no descargado, preguntar al usuario
      console.log('ğŸ’¬ Mostrando prompt de descarga al usuario...');
      const download = confirm(
        'ğŸ”§ El Sandbox local no estÃ¡ disponible.\n\n' +
        'Â¿Deseas descargar DotNetInteractiveServer.zip para ejecutar cÃ³digo localmente?\n\n' +
        '(La descarga comenzarÃ¡ automÃ¡ticamente si aceptas)'
      );

      if (download) {
        console.log('âœ… Usuario aceptÃ³ descargar el sandbox');
        await downloadSandbox();
      } else {
        console.log('âŒ Usuario rechazÃ³ la descarga');
        btnSandbox.title = 'Sandbox no disponible. Usa el botÃ³n "ğŸ“¥ Descargar Sandbox" si cambias de opiniÃ³n.';
        btnValidation.title = 'Sandbox no disponible. Usa el botÃ³n "ğŸ“¥ Descargar Sandbox" si cambias de opiniÃ³n.';
      }
    }

    // Descargar el sandbox
    async function downloadSandbox() {
      const btnSandbox = document.getElementById('btnSandbox');
      const btnValidation = document.getElementById('btnValidation');
      
      btnSandbox.textContent = 'â³ Descargando sandbox...';
      btnValidation.textContent = 'â³ Descargando sandbox...';

      try {
        // Crear enlace de descarga
        const a = document.createElement('a');
        a.href = SANDBOX_DOWNLOAD_URL;
        a.download = 'DotNetInteractiveServer.zip';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

        // Marcar como descargado en localStorage
        localStorage.setItem('sandboxDownloaded', 'true');

        // Mostrar instrucciones
        alert(
          'âœ… Descarga iniciada: DotNetInteractiveServer.zip\n\n' +
          'ğŸ“ Instrucciones:\n' +
          '1. Extrae el archivo ZIP\n' +
          '2. Ejecuta DotNetInteractiveServer.exe (Windows) o el equivalente en tu sistema\n' +
          '3. Los botones se habilitarÃ¡n automÃ¡ticamente cuando detecte el sandbox corriendo\n\n' +
          'ğŸ’¡ Esta pÃ¡gina verificarÃ¡ cada 5 segundos si el sandbox estÃ¡ disponible.'
        );

        btnSandbox.textContent = 'ğŸ§ª Probar en Sandbox';
        btnValidation.textContent = 'ğŸ“‚ Validar con DataSet local';
        btnSandbox.title = 'Esperando que ejecutes el sandbox local...';
        btnValidation.title = 'Esperando que ejecutes el sandbox local...';

        // Iniciar monitoreo automÃ¡tico
        startSandboxMonitoring();

      } catch (err) {
        console.error('Error al descargar sandbox:', err);
        alert('âŒ Error al descargar el sandbox. Verifica la conexiÃ³n e intenta nuevamente.');
        btnSandbox.textContent = 'ğŸ§ª Probar en Sandbox';
        btnValidation.textContent = 'ğŸ“‚ Validar con DataSet local';
      }
    }

    // BOOKMARK: GestiÃ³n de datasets - sincronizaciÃ³n incremental
    // Obtiene del sandbox lo ya instalado
    async function getInstalledDataset(problemId) {
      const res = await fetch(`${SANDBOX_BASE}/datasets/${encodeURIComponent(problemId)}`);
      if (!res.ok) throw new Error(`Sandbox no responde datasets (${res.status})`);
      return await res.json(); // { installed, inputs[], expected[] }
    }

    // Obtiene del servidor las listas oficiales
    async function getServerLists(problemId) {
      console.log(`ğŸ“‹ Obteniendo listas del servidor para problema ${problemId}...`);
      try {
        const [ri, re] = await Promise.all([
          fetch(`/problems/${problemId}/inputs`),
          fetch(`/problems/${problemId}/expected`)
        ]);
        
        if (!ri.ok) throw new Error(`No se pudieron listar inputs (status ${ri.status})`);
        
        const inputs = await ri.json();
        console.log(`ğŸ“¥ Inputs encontrados:`, inputs);
        
        let expected = [];
        if (re.ok) {
          expected = await re.json();
          console.log(`ğŸ“¥ Expected encontrados:`, expected);
        } else {
          console.log(`âš ï¸ No hay outputs esperados (status ${re.status})`);
        }
        
        return { inputs, expected };
      } catch (err) {
        console.error('âŒ Error obteniendo listas del servidor:', err);
        throw err;
      }
    }

    // Descarga contenido de un archivo del servidor
    async function fetchServerFile(problemId, kind /* "input"|"expected" */, fileName) {
      const route = kind === "input" 
        ? `/problems/${problemId}/input/${fileName}`
        : `/problems/${problemId}/expected/${fileName}`;
      
      console.log(`ğŸ“¥ Descargando archivo: ${route}`);
      const res = await fetch(route);
      if (!res.ok) throw new Error(`No se pudo descargar ${fileName} (status ${res.status})`);
      return await res.text();
    }

    // Sube SOLO lo que falta
    async function syncDataset(problemId) {
      console.log(`ğŸ”„ Iniciando sincronizaciÃ³n para problema ${problemId}...`);
      
      // Deshabilitar botones del sandbox durante la sincronizaciÃ³n
      disableSandboxButtons("â³ Sincronizando...");
      
      // Obtener referencia al Ã¡rea de output
      const outputDiv = document.getElementById('output');
      if (outputDiv) {
        outputDiv.innerHTML = '<div style="color: #007bff; font-weight: bold;">ğŸ”„ Iniciando sincronizaciÃ³n del dataset...</div>';
      }
      
      try {
        // 1) Preguntar al sandbox quÃ© ya tiene
        console.log(`ğŸ“¡ Consultando al sandbox quÃ© archivos ya tiene...`);
        if (outputDiv) outputDiv.innerHTML = '<div>ğŸ“¡ Verificando archivos instalados en sandbox...</div>';
        const installed = await getInstalledDataset(problemId);
        console.log(`ğŸ“¦ Sandbox tiene:`, installed);

        // 2) Preguntar al servidor quÃ© deberÃ­a tener
        console.log(`ğŸ“¡ Consultando al servidor quÃ© archivos deberÃ­a tener...`);
        if (outputDiv) outputDiv.innerHTML = '<div>ğŸ“¡ Consultando archivos disponibles en servidor...</div>';
        const server = await getServerLists(problemId);

        // 3) Calcular faltantes
        const installedInputs   = new Set(installed.inputs ?? []);
        const installedExpected = new Set(installed.expected ?? []);
        const missingInputs   = server.inputs.filter(f => !installedInputs.has(f));
        const missingExpected = server.expected.filter(f => !installedExpected.has(f));

        console.log(`ğŸ“Š Archivos faltantes - Inputs: ${missingInputs.length}, Expected: ${missingExpected.length}`);

        if (missingInputs.length === 0 && missingExpected.length === 0) {
          console.log(`âœ… ${problemId}: DataSet ya estÃ¡ completo`);
          if (outputDiv) outputDiv.innerHTML = '<div style="color: #28a745; font-weight: bold;">âœ… Dataset ya estÃ¡ completo</div>';
          return { uploaded: 0 };
        }

        // 4) Descargar solo faltantes y armar payload
        const files = [];
        const totalFiles = missingInputs.length + missingExpected.length;
        let downloadedCount = 0;

        if (outputDiv) outputDiv.innerHTML = `<div style="color: #17a2b8;">â¬‡ï¸ Descargando archivos... (0/${totalFiles})</div>`;
        
        console.log(`â¬‡ï¸ Descargando ${missingInputs.length} inputs faltantes...`);
        for (const f of missingInputs) {
          downloadedCount++;
          if (outputDiv) outputDiv.innerHTML = `<div style="color: #17a2b8;">ğŸ“¥ Descargando archivo ${downloadedCount}/${totalFiles}: ${f}</div>`;
          const content = await fetchServerFile(problemId, "input", f);
          files.push({ path: `DataSet/${f}`, content });
        }
        
        console.log(`â¬‡ï¸ Descargando ${missingExpected.length} expected faltantes...`);
        for (const f of missingExpected) {
          downloadedCount++;
          if (outputDiv) outputDiv.innerHTML = `<div style="color: #17a2b8;">ğŸ“¥ Descargando archivo ${downloadedCount}/${totalFiles}: ${f}</div>`;
          const content = await fetchServerFile(problemId, "expected", f);
          files.push({ path: `.Expected/${f}`, content });
        }

        // 5) Enviar al sandbox
        console.log(`ğŸ“¤ Enviando ${files.length} archivos al sandbox...`);
        if (outputDiv) outputDiv.innerHTML = `<div style="color: #17a2b8;">ğŸ“¤ Enviando ${files.length} archivos al sandbox...</div>`;
        await sendDatasetToSandbox(problemId, files);
        console.log(`âœ… SincronizaciÃ³n completada: ${files.length} archivos subidos`);
        if (outputDiv) outputDiv.innerHTML = `<div style="color: #28a745; font-weight: bold;">âœ… SincronizaciÃ³n completada: ${files.length} archivos sincronizados</div>`;
        return { uploaded: files.length };
      } catch (err) {
        console.error(`âŒ Error en syncDataset para ${problemId}:`, err);
        if (outputDiv) outputDiv.innerHTML = `<div style="color: #dc3545; font-weight: bold;">âŒ Error: ${err.message}</div>`;
        throw err;
      } finally {
        // Siempre rehabilitar botones al terminar (Ã©xito o error)
        enableSandboxButtons();
      }
    }

    // â€œEnsureâ€: si no estÃ¡ completo, sincroniza; si estÃ¡, no hace nada
    async function ensureDatasetInstalled(problemId) {
      try {
        const res = await syncDataset(problemId);
        if (res.uploaded === 0) {
          console.log(`âœ… ${problemId}: ya estaba instalado`);
        }
      } catch (err) {
        console.error("Error al asegurar dataset:", err);
        alert("âŒ No se pudo asegurar el DataSet en el sandbox.");
      }
    }

    // BOOKMARK: EjecuciÃ³n de cÃ³digo en sandbox local
    // ğŸ”¹ Ejecutar el cÃ³digo en el sandbox local
    async function runLocalCode() {
      const output = document.getElementById("output");
      output.textContent = "â³ Ejecutando cÃ³digo en el sandbox local...\n";

      const raw = getCurrentCode();
      const code = normalizeCodeForKernel(raw);
      console.log("CÃ³digo enviado =>", code);

      if (!code.trim()) {
        output.textContent = "âš ï¸ No hay cÃ³digo para ejecutar.";
        return;
      }

      // Obtener el stdin del textarea
      const stdin = document.getElementById('stdin').value;

      try {
        // BOOKMARK: Ejecutar execute con cÃ³digo y stdin en el sandbox
        const log = document.getElementById("validationLog");
        log.textContent = "âœ… CÃ³digo ejecutado, esperando respuesta...\n";
        
        const res = await fetch(`${SANDBOX_URL}/execute`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            code: code,
            stdin: stdin  // âœ¨ El sandbox acepta stdin
          }),
        });

        log.textContent = "";

        if (!res.ok) throw new Error(`Error HTTP ${res.status}`);

        const data = await res.json();
        console.log("Respuesta del sandbox:", data);

        // El servidor devuelve { output: "..." }
        const outputText = data.output || "";

        output.textContent =
          "ğŸ–¥ï¸ Salida del programa:\n\n" +
          (outputText.trim() || "(sin salida)");
      } catch (err) {
        console.error(err);
        output.textContent =
          "âŒ No se pudo conectar al sandbox local.\n" +
          "AsegÃºrate de haber ejecutado DotNetInteractiveServer.exe.\n\n" +
          err.message;
      }
    }

    // BOOKMARK: NormalizaciÃ³n de cÃ³digo para .NET Interactive Kernel
    // Normaliza el cÃ³digo para enviarlo al kernel (elimina clase Program y Main)
    function normalizeCodeForKernel(sourceCode) {
      return sourceCode
        // Elimina â€œclass Programâ€ o â€œpublic class Programâ€
        .replace(/\b(public\s+)?class\s+Program\s*/g, "")
        // Elimina â€œstatic void Main()â€, â€œpublic static void Main()â€ o con args
        .replace(/\b(public\s+)?static\s+void\s+Main\s*\([^)]*\)\s*/g, "")
        .trim();
    }


    // BOOKMARK: ValidaciÃ³n offline con datasets locales
    // ğŸ”¹ Validar el cÃ³digo con datasets del sandbox
    async function runOfflineValidation() {
      const log = document.getElementById("validationLog");
      const output = document.getElementById("output");
      
      // Obtener el problema actual
      const problemId = document.getElementById("txtProblemId").value;
      
      if (!problemId) {
        output.textContent = "âš ï¸ Selecciona un problema primero.";
        output.className = "result warn";
        return;
      }

      const code = getCurrentCode();
      if (!code.trim()) {
        output.textContent = "âš ï¸ No hay cÃ³digo para validar.";
        output.className = "result warn";
        return;
      }

      log.textContent = "ğŸ“‚ Ejecutando validaciÃ³n con DataSet local del sandbox...\n";
      output.textContent = "â³ Validando...";
      output.className = "result warn";

      // Deshabilitar botones del sandbox durante la validaciÃ³n
      disableSandboxButtons("â³ Validando...");

      try {
        console.log(`ğŸ§ª Validando problema ${problemId} con sandbox...`);

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BOOKMARK: STREAMING CON SERVER-SENT EVENTS (SSE)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Enviamos la peticiÃ³n al sandbox para validar el cÃ³digo.
        // El servidor NO envÃ­a una respuesta Ãºnica, sino un STREAM continuo
        // de eventos (como un rÃ­o de datos que va llegando de a poco).
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        fetch(`${SANDBOX_URL}/validate-dataset`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            'Accept': 'text/event-stream'  // âœ¨ Le decimos al servidor: "quiero streaming SSE"
          },
          body: JSON.stringify({
            code: normalizeCodeForKernel(code),
            problem: problemId,
            timeoutMs: 5000
          })
        }).then(response => {
          // Verificar que el servidor respondiÃ³ correctamente
          if (!response.ok) {
            throw new Error(`Error HTTP ${response.status}`);
          }
          
          // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          // CONFIGURACIÃ“N DEL LECTOR DE STREAM
          // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          // reader: Objeto que nos permite leer el stream de datos "chunk por chunk"
          //         (chunk = pedazo de datos que llega cada vez)
          const reader = response.body.getReader();
          
          // decoder: Convierte bytes (nÃºmeros) a texto legible
          const decoder = new TextDecoder();
          
          // buffer: Almacena texto incompleto entre chunks
          //         A veces un mensaje llega partido en 2 chunks, el buffer lo guarda
          let buffer = '';
          
          // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          // FUNCIÃ“N RECURSIVA: processStream()
          // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          // Esta funciÃ³n se llama a sÃ­ misma para leer chunk tras chunk
          // hasta que el servidor termine de enviar datos.
          //
          // Â¿Por quÃ© recursiva y no un loop?
          // Porque reader.read() es ASÃNCRONA (devuelve una promesa).
          // No podemos hacer: while(!done) { read(); } â† esto no funciona con async
          // En cambio: read().then(() => processStream()) â† esto SÃ funciona
          // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          function processStream() {
            // Leer el siguiente chunk del stream
            reader.read().then(({ done, value }) => {
              // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              // CASO 1: El stream terminÃ³ (done = true)
              // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              if (done) {
                console.log('âœ… Stream completado - No hay mÃ¡s datos del servidor');
                enableSandboxButtons();  // âœ… Rehabilitar botones al terminar exitosamente
                return;  // ğŸ›‘ FIN DE LA RECURSIÃ“N - La funciÃ³n no se vuelve a llamar
              }
              
              // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              // CASO 2: LlegÃ³ un chunk de datos (value contiene bytes)
              // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              
              // 1ï¸âƒ£ Convertir bytes a texto y agregarlo al buffer
              //    { stream: true } = "puede haber mÃ¡s datos despuÃ©s"
              buffer += decoder.decode(value, { stream: true });
              
              // 2ï¸âƒ£ Separar el buffer en lÃ­neas (los eventos SSE vienen lÃ­nea por lÃ­nea)
              const lines = buffer.split('\n');
              
              // 3ï¸âƒ£ Guardar la Ãºltima lÃ­nea (puede estar incompleta)
              //    lines.pop() saca y devuelve el Ãºltimo elemento del array
              //    Si estÃ¡ vacÃ­o, usamos '' (cadena vacÃ­a)
              buffer = lines.pop() || '';
              
              // 4ï¸âƒ£ Procesar cada lÃ­nea completa
              //    Formato SSE:
              //    event: start
              //    data: {"totalCases": 5}
              //
              //    event: case-result
              //    data: {"caseNumber": 1, "result": "Accepted"}
              for (const line of lines) {
                // Â¿La lÃ­nea comienza con "event:"?
                if (line.startsWith('event:')) {
                  // Extraer el tipo de evento (ejemplo: "start", "case-result", "complete")
                  const eventType = line.substring(6).trim();  // substring(6) = omite "event:"
                  
                  // Buscar la siguiente lÃ­nea que debe tener los datos (data:)
                  const dataLineIndex = lines.indexOf(line) + 1;
                  
                  // Verificar que existe la lÃ­nea de datos
                  if (dataLineIndex < lines.length && lines[dataLineIndex].startsWith('data:')) {
                    // Extraer el JSON (omitiendo "data: ")
                    const jsonText = lines[dataLineIndex].substring(5).trim();
                    
                    // Convertir el texto JSON a un objeto JavaScript
                    const data = JSON.parse(jsonText);
                    
                    // ğŸ¯ Llamar a la funciÃ³n que maneja el evento
                    //    (esta funciÃ³n muestra los resultados en la UI)
                    handleSSEEvent(eventType, data);
                  }
                }
              }
              
              // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              // ğŸ”„ RECURSIÃ“N: Llamarse a sÃ­ misma para leer el siguiente chunk
              // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              // Esta es la clave del streaming:
              // 1. Leemos un chunk
              // 2. Lo procesamos
              // 3. Llamamos a processStream() de nuevo para leer el siguiente
              // 4. Repetimos hasta que done=true
              //
              // Flujo visual:
              // Server â†’ [chunk1] â†’ processStream() â†’ procesa â†’ llama processStream()
              //                                                           â†“
              // Server â†’ [chunk2] â†’ processStream() â†’ procesa â†’ llama processStream()
              //                                                           â†“
              // Server â†’ [chunk3] â†’ processStream() â†’ procesa â†’ llama processStream()
              //                                                           â†“
              // Server â†’ [done=true] â†’ processStream() â†’ return (fin)
              processStream();
              
            }).catch(streamErr => {
              // Si hay un error leyendo el stream, mostrarlo
              console.error('âŒ Error en stream:', streamErr);
              log.textContent += `\nâŒ Error en stream: ${streamErr.message}\n`;
              output.textContent = `âŒ Error procesando resultados: ${streamErr.message}`;
              output.className = "result err";
              enableSandboxButtons();  // âœ… Rehabilitar botones si hay error en el stream
            });
          }
          
          // ğŸš€ Primera llamada a processStream() para iniciar la lectura
          processStream();
        }).catch(err => {
          console.error('âŒ Error en validaciÃ³n:', err);
          log.textContent += `\nâŒ Error: ${err.message}\n`;
          output.textContent = 
            "âŒ No se pudo validar con el sandbox.\n" +
            "AsegÃºrate de:\n" +
            "1. Tener el sandbox ejecutÃ¡ndose\n" +
            "2. Haber sincronizado los datasets del problema\n\n" +
            err.message;
          output.className = "result err";
          enableSandboxButtons();  // âœ… Rehabilitar botones si hay error en la peticiÃ³n
        });

      } catch (err) {
        console.error("Error en validaciÃ³n:", err);
        log.textContent += `\nâŒ Error: ${err.message}\n`;
        output.textContent = 
          "âŒ No se pudo validar con el sandbox.\n" +
          "AsegÃºrate de:\n" +
          "1. Tener el sandbox ejecutÃ¡ndose\n" +
          "2. Haber sincronizado los datasets del problema\n\n" +
          err.message;
        output.className = "result err";
        enableSandboxButtons();  // âœ… Rehabilitar botones si hay error en el try-catch
      }
    }

    // BOOKMARK: Manejo de eventos SSE del sandbox durante la validaciÃ³n
    function handleSSEEvent(eventType, data) {
        const log = document.getElementById('validationLog');
        const output = document.getElementById('output');
        
        if (eventType === 'start') {
            log.textContent = `ğŸš€ Iniciando validaciÃ³n de ${data.totalCases} casos para problema ${data.problem}...\n\n`;
            output.className = 'result';
            output.textContent = '';
        }
        else if (eventType === 'case-result') {
            const percent = Math.round((data.caseNumber / data.totalCases) * 100);
            
            // Actualizar output con progreso
            output.textContent = `â³ Procesando caso ${data.caseNumber}/${data.totalCases} (${percent}%): ${data.caseName}`;
            
            // Agregar resultado al log
            const resultIcon = data.result === 'Accepted' ? 'âœ…' : 
                              data.result === 'Wrong Answer' ? 'âŒ' : 
                              data.result === 'Error' ? 'âš ï¸' : 'â“';
            
            let resultLine = `${resultIcon} Caso ${data.caseNumber}/${data.totalCases}: ${data.caseName} â†’ ${data.result} (${data.timeMs}ms)\n`;
            
            if (data.diff) {
                resultLine += `   Diferencia:\n${data.diff}\n`;
            }
            
            log.textContent += resultLine;
            
            // Auto-scroll al final del log
            log.scrollTop = log.scrollHeight;
        }
        else if (eventType === 'complete') {
            output.textContent = `âœ… ValidaciÃ³n completada - ${data.totalCases} casos procesados`;
            output.className = 'result ok';
            log.textContent += `\nâœ… ValidaciÃ³n completada - ${data.totalCases} casos procesados\n`;
        }
    }

    // BOOKMARK: EnvÃ­o de datasets al sandbox
    // ----------------------------------------------------------------------
    //  Enviar dataset al sandbox local
    // ----------------------------------------------------------------------
    async function sendDatasetToSandbox(problemId, files) {
      try {
        const res = await fetch(SANDBOX_BASE + "/upload-dataset", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ problemId, files }),
        });

        if (!res.ok) throw new Error(`Error HTTP ${res.status}`);
        const data = await res.json();
        console.log("Sandbox respondiÃ³:", data);

        if (data.ok) {
          alert(`âœ… DataSet ${data.problem} instalado (${data.saved} archivos).`);
        } else {
          alert("âš ï¸ No se pudo instalar el DataSet.");
        }
      } catch (err) {
        console.error("Error enviando DataSet:", err);
        alert("âŒ No se pudo enviar el DataSet al sandbox local.");
      }
    }

    // BOOKMARK: Carga de estudiantes y notificaciÃ³n de login
    // === Cargar estudiantes en el select ===
    async function loadStudents() {
      try {
        const response = await fetch("/students");
        const estudiantes = await response.json();

        const select = document.getElementById("selectStudent");
        estudiantes.forEach(est => {
          const opt = document.createElement("option");
          opt.value = est.studentId;     // nÃºmero de registro
          opt.textContent = est.name;    // nombre visible
          select.appendChild(opt);
        });

        // === FunciÃ³n para notificar selecciÃ³n de estudiante al backend ===
        async function notifyStudentSelection(studentId) {
          try {
            console.log(`ï¿½ Notificando selecciÃ³n de estudiante: ${studentId}`);
            
            const response = await fetch("/api/student-login", {
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                studentId: studentId,
                timestamp: new Date().toISOString(),
                action: "login"
              })
            });

            if (response.ok) {
              const result = await response.json();
              console.log("âœ… Estudiante registrado correctamente:", result);
              
              // Mostrar mensaje de bienvenida
              showMessage(`âœ… ${result.message}`, "ok");
            } else {
              // Error del servidor - manejar bloqueos y otros errores
              const errorData = await response.json();
              console.error("âŒ Error del servidor:", errorData);
              
              if (response.status === 400 && errorData.error) {
                // Bloqueo por IP - mostrar alerta prominente
                alert(`ğŸš« ACCESO BLOQUEADO\n\n${errorData.error}\n\nContacte al instructor si necesita ayuda.`);
                
                // Revertir la selecciÃ³n del dropdown
                document.getElementById("selectStudent").value = "";
                document.getElementById("txtStudentId").value = "";
                
                // Mostrar mensaje de error en la interfaz
                showMessage(`âŒ BLOQUEADO: ${errorData.error}`, "err");
              } else {
                // Otro tipo de error
                showMessage(`âš ï¸ Error al registrar estudiante: ${response.status}`, "warn");
              }
            }
          } catch (error) {
            console.error("âŒ Error de conexiÃ³n:", error);
          }
        }

        // ğŸ”¥ Cuando cambie el select â†’ copiar el valor al input y notificar al backend
        select.addEventListener("change", async () => {
          const selectedValue = select.value;
          if (selectedValue) {
            // Temporalmente actualizar el campo (se revertirÃ¡ si hay error)
            document.getElementById("txtStudentId").value = selectedValue;
            
            // Notificar al backend sobre la selecciÃ³n del estudiante
            // Si hay bloqueo, la funciÃ³n notifyStudentSelection revertirÃ¡ automÃ¡ticamente
            await notifyStudentSelection(selectedValue);
          } else {
            // Si deseleccionÃ³, limpiar el campo
            document.getElementById("txtStudentId").value = "";
          }
        });

      } catch (err) {
        console.error("Error cargando estudiantes:", err);
      }
    }


    // Cargar al inicio
    loadStudents();
  </script>
  
  <script>
    // BOOKMARK: Carga de problemas y sincronizaciÃ³n automÃ¡tica de datasets
    async function loadProblems() {
      try {
        const response = await fetch("/contest/questions");
        const problemas = await response.json();

        const select = document.getElementById("selectProblem");
        problemas.forEach(p => {
          const opt = document.createElement("option");
          opt.value = p.id;
          opt.textContent = p.titulo;
          select.appendChild(opt);
        });

        // Cuando selecciona un problema, obtener enunciado
        select.addEventListener("change", async () => {
            const id = select.value;
            if (!id) {
              document.getElementById("txtProblemDesc").value = "";
              return;
            }

            try {
              //const response = await fetch(`/questions/${id}/desc`);
              //const data = await response.json();
              //document.getElementById("txtProblemDesc").value = data.text;
              const response = await fetch(`/questions/${id}/desc`);
              const data = await response.json();

              // 1) ğŸ‘‡ AquÃ­ se usa, directamente, el objeto que devuelve el backend
              document.getElementById("txtProblemId").value = data.id;  // Con este nombre  ("id"), se definio en el backend
              document.getElementById("txtProblemDesc").value = data.text;  // Con este nombre  ("id"), se definio en el backend
              
              // 2) ğŸ‘‡ AquÃ­ se cargan datasets (inputs) de ese problema
              await loadInputs(id);
              
              // 3) ğŸ”„ Si el sandbox estÃ¡ disponible, sincronizar datasets automÃ¡ticamente
              if (sandboxAvailable) {
                try {
                  console.log(`ğŸ”„ Sincronizando dataset para problema ${id}...`);
                  const result = await syncDataset(id);
                  if (result.uploaded > 0) {
                    console.log(`âœ… Sincronizados ${result.uploaded} archivos para problema ${id}`);
                    showToast(`âœ… Dataset sincronizado (${result.uploaded} archivos)`, "success");
                  } else {
                    console.log(`âœ… Dataset ya estaba completo para problema ${id}`);
                  }
                } catch (err) {
                  console.error("Error sincronizando dataset:", err);
                  showToast("âš ï¸ No se pudo sincronizar el dataset", "warn");
                }
              }
                      
            } catch (err) {
              console.error("Error cargando enunciado:", err);
            }
          });
        } catch (err) {
          console.error("Error cargando problemas:", err);
      }
    }

    // Cargar al inicio
    loadProblems();
  </script>

  <script>
    async function loadInputs(problemId) {
      const select = document.getElementById("selectInput");
      select.innerHTML = "<option value=''>-- Seleccione un dataset --</option>";

      try {
        const response = await fetch(`/problems/${problemId}/inputs`);
        if (!response.ok) {
          console.error("Error cargando inputs:", await response.text());
          return;
        }
        const archivos = await response.json();
        archivos.forEach(a => {
          const opt = document.createElement("option");
          opt.value = a;
          opt.textContent = a;
          select.appendChild(opt);
        });

        // evento: cuando selecciona un dataset
        select.addEventListener("change", async () => {
          const archivo = select.value;
          if (!archivo) return;

          try {
            const r = await fetch(`/problems/${problemId}/input/${archivo}`);
            const contenido = await r.text();
            document.getElementById("stdin").value = contenido;
          } catch (err) {
            console.error("Error cargando contenido:", err);
          }
        });

      } catch (err) {
        console.error("Error:", err);
      }
    }
    </script>
    
    <script>
      /*
      Al abrir index.html: se descarga /utils/tree (solo la primera vez).
      1. - El alumno ve un explorador de carpetas.
      2. - Puede expandir/cerrar carpetas.
      3. - Al hacer clic en un archivo â†’ se abre el cÃ³digo en el textarea, listo para copiar/pegar.
  `   4. - Todo queda cacheado en IndexedDB â†’ si se abre de nuevo, no hace otra request al servidor.
      */
      // --- IndexedDB Helper ---
      const DB_NAME = "UtilsDB";
      const DB_STORE = "files";
      function openDB() {
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(DB_NAME, 1);
          req.onupgradeneeded = () => req.result.createObjectStore(DB_STORE);
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      }
      async function cachePut(key, value) {
        const db = await openDB();
        const tx = db.transaction(DB_STORE, "readwrite");
        tx.objectStore(DB_STORE).put(value, key);
      }
      async function cacheGet(key) {
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(DB_STORE, "readonly");
          const req = tx.objectStore(DB_STORE).get(key);
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      }

      // --- Render tree ---
      function renderTree(node, container, isRoot = false) {
        if (node.type === "dir") {
          const div = document.createElement("div");
          div.className = "folder";
          div.textContent = "ğŸ“‚ " + node.name;
          container.appendChild(div);

          const children = document.createElement("div");
          children.style.marginLeft = "15px";
          // ğŸ‘‡ Si es el directorio raÃ­z â†’ expandido, si no â†’ oculto
          children.style.display = isRoot ? "block" : "none";
          container.appendChild(children);

          div.onclick = () => {
            children.style.display = children.style.display === "none" ? "block" : "none";
          };

          node.children.forEach(child => renderTree(child, children));
        } else if (node.type === "file") {
          const div = document.createElement("div");
          div.className = "file";
          div.textContent = "ğŸ“„ " + node.name;
          div.onclick = () => loadFile(node.path);
          container.appendChild(div);
        }
      }


      // --- Load file (with cache) ---
      async function loadFile(path) {
        let content = await cacheGet(path);
        if (!content) {
          const res = await fetch(`/utils/file/${path}`);
          if (!res.ok) {
            alert("No se pudo cargar " + path);
            return;
          }
          content = await res.text();
          await cachePut(path, content);
        }
        document.getElementById("utils-content").value = content;
      }

      // --- Init ---
      async function initUtils() {
        try {
          let tree = await cacheGet("tree");
          if (!tree) {
            const res = await fetch("/utils/tree");
            tree = await res.json();
            await cachePut("tree", tree);
          }
          
          const container = document.getElementById("utils-tree");
          container.innerHTML = "";
          renderTree(tree, container, true); // ğŸ‘ˆ el raÃ­z expandido

        } catch (err) {
          console.error("Error cargando utilitarios:", err);
        }
      }
      initUtils();
      </script>

      <script>
        /*
        - Al copiar cÃ³digo â†’ aparece un toast verde âœ… confirmando.
        - Si no hay contenido â†’ un toast naranja âš ï¸.
        - Si ocurre un error â†’ un toast rojo âŒ.
        - Todos se desvanecen solos despuÃ©s de 3 segundos.
        */
        // Mostrar toast
        function showToast(message, type = "info") {
          const container = document.getElementById("toast-container");
          const toast = document.createElement("div");
          toast.className = "toast";
          toast.textContent = message;

          // Color segÃºn tipo
          if (type === "success") toast.style.background = "#4caf50";
          if (type === "error") toast.style.background = "#f44336";
          if (type === "warn") toast.style.background = "#ff9800";

          container.appendChild(toast);

          // Mostrar
          setTimeout(() => toast.classList.add("show"), 50);

          // Ocultar y eliminar
          setTimeout(() => {
            toast.classList.remove("show");
            setTimeout(() => toast.remove(), 500);
          }, 3000);
        }

        // Copiar al portapapeles con toast
        document.getElementById("copy-btn").addEventListener("click", async () => {
          const textarea = document.getElementById("utils-content");
          if (!textarea.value.trim()) {
            showToast("âš ï¸ No hay contenido para copiar.", "warn");
            return;
          }
          try {
            await navigator.clipboard.writeText(textarea.value);
            showToast("âœ… CÃ³digo copiado al portapapeles.", "success");
          } catch (err) {
            console.error("Error al copiar:", err);
            showToast("âŒ No se pudo copiar el contenido.", "error");
          }
        });
        </script>

      <div id="toast-container"></div>
      
      
      <script>
        // --- Modo oscuro / claro ---
        const themeToggle = document.getElementById("theme-toggle");

        // Leer tema guardado
        const savedTheme = localStorage.getItem("theme") || "light";
        applyTheme(savedTheme);

        themeToggle.addEventListener("click", () => {
          const current = document.body.classList.contains("dark-mode") ? "dark" : "light";
          const next = current === "dark" ? "light" : "dark";
          applyTheme(next);
          localStorage.setItem("theme", next);
        });

        function applyTheme(mode) {
          if (mode === "dark") {
            document.body.classList.add("dark-mode");
            themeToggle.textContent = "â˜€ï¸";
            if (monacoEditor) monaco.editor.setTheme("vs-dark");
            document.querySelectorAll(".CodeMirror").forEach(cm => cm.classList.add("cm-s-monokai"));
          } else {
            document.body.classList.remove("dark-mode");
            themeToggle.textContent = "ğŸŒ™";
            if (monacoEditor) monaco.editor.setTheme("vs-light");
            document.querySelectorAll(".CodeMirror").forEach(cm => cm.classList.remove("cm-s-monokai"));
          }
        }
      </script>

</body>
</html>

